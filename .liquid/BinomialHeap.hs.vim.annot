1:1-1:1::Data.Heap.Binominal.$trModule :: "GHC.Types.Module"
60:1-60:29::Data.Heap.Binominal.boundedTreeTransitivityLemma :: "forall a .\nx1:a -> x2:{VV : a | x1 <= VV} -> (Data.Heap.Binominal.Tree {VV : a | x2 <= VV}) -> (Data.Heap.Binominal.Tree {VV : a | x1 <= VV})"
60:30-60:31::x :: "a"
60:32-60:33::y :: "{VV : a | x <= VV}"
60:34-60:38::tree :: "(Data.Heap.Binominal.Tree {VV : a | y <= VV})"
71:1-71:5::Data.Heap.Binominal.rank :: "forall a . (Data.Heap.Binominal.Tree a) -> GHC.Types.Int"
71:27-71:28::ds_d2ry :: "GHC.Types.Int"
75:1-75:5::Data.Heap.Binominal.root :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> {VV : a | VV == root x1}"
75:27-75:28::ds_d2ro :: "a"
81:1-81:7::Data.Heap.Binominal.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
81:10-81:11::x :: "a"
85:1-85:28::Data.Heap.Binominal.treeIsBoundedByItsRootLemma :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree {VV : a | root x1 <= VV})"
86:3-86:39::Data.Heap.Binominal.Node :: "forall a .\nx1:GHC.Types.Int -> x2:a -> x3:[(Data.Heap.Binominal.Tree {VV : a | x2 <= VV})] -> {v : (Data.Heap.Binominal.Tree a) | subtrees v == x3\n                                                                                                                       && _root v == x2\n                                                                                                                       && _rank v == x1\n                                                                                                                       && root v == x2}"
86:15-86:16::ds_d2r9 :: "GHC.Types.Int"
86:24-86:25::ds_d2ra :: "a"
86:36-86:38::ds_d2rb :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
89:1-89:5::Data.Heap.Binominal.link :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree a)"
89:6-89:8::t1 :: "(Data.Heap.Binominal.Tree a)"
89:51-89:53::t2 :: "(Data.Heap.Binominal.Tree a)"
90:5-90:7::ds_d2rX :: "a"
90:11-90:13::ds_d2s0 :: "a"
91:9-91:22::t2BoundedByX2 :: "(Data.Heap.Binominal.Tree a)"
91:25-91:55::_ :: "(Data.Heap.Binominal.Tree a)"
91:53-91:55::lq_anf$##7205759403792803047 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
92:9-92:22::t2BoundedByX1 :: "(Data.Heap.Binominal.Tree a)"
92:25-92:73::_ :: "(Data.Heap.Binominal.Tree a)"
92:54-92:56::ds_d2rX :: "a"
92:57-92:59::ds_d2s0 :: "a"
92:60-92:73::t2BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2BoundedByX2}"
93:10-93:16::lq_anf$##7205759403792803056 :: "GHC.Types.Int"
93:11-93:13::ds_d2rW :: "GHC.Types.Int"
93:14-93:15::lq_anf$##7205759403792803055 :: "GHC.Types.Int"
93:17-93:19::ds_d2rX :: "a"
93:20-93:39::lq_anf$##7205759403792803057 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t2BoundedByX1}"
93:21-93:34::t2BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2BoundedByX1}"
93:35-93:38::ds_d2rY :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
95:9-95:22::t1BoundedByX1 :: "(Data.Heap.Binominal.Tree a)"
95:25-95:55::_ :: "(Data.Heap.Binominal.Tree a)"
95:53-95:55::lq_anf$##7205759403792803046 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
96:9-96:22::t1BoundedByX2 :: "(Data.Heap.Binominal.Tree a)"
96:25-96:73::_ :: "(Data.Heap.Binominal.Tree a)"
96:54-96:56::ds_d2s0 :: "a"
96:57-96:59::ds_d2rX :: "a"
96:60-96:73::t1BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1BoundedByX1}"
97:12-97:18::lq_anf$##7205759403792803052 :: "GHC.Types.Int"
97:13-97:15::ds_d2rZ :: "GHC.Types.Int"
97:16-97:17::lq_anf$##7205759403792803051 :: "GHC.Types.Int"
97:19-97:21::ds_d2s0 :: "a"
97:22-97:41::lq_anf$##7205759403792803053 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t1BoundedByX2}"
97:23-97:36::t1BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1BoundedByX2}"
97:37-97:40::ds_d2s1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"