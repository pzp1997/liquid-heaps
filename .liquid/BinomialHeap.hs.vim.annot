1:1-1:1::Data.Heap.Binominal.$trModule :: "GHC.Types.Module"
61:1-61:28::Data.Heap.Binominal.treeIsBoundedByItsRootLemma :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree {VV : a | root x1 <= VV})"
62:3-62:37::Data.Heap.Binominal.Node :: "forall a .\nx1:{v : GHC.Types.Int | v >= 0} -> x2:a -> x3:[(Data.Heap.Binominal.Tree {VV : a | x2 <= VV})] -> {v : (Data.Heap.Binominal.Tree a) | subtrees v == x3\n                                                                                                                                      && root v == x2\n                                                                                                                                      && rank v == x1}"
62:14-62:15::ds_d3dW :: "{v : GHC.Types.Int | v >= 0}"
62:22-62:23::ds_d3dX :: "a"
62:34-62:36::ds_d3dY :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
66:1-66:29::Data.Heap.Binominal.boundedTreeTransitivityLemma :: "forall a .\nx1:a -> x2:{VV : a | x1 <= VV} -> (Data.Heap.Binominal.Tree {VV : a | x2 <= VV}) -> (Data.Heap.Binominal.Tree {VV : a | x1 <= VV})"
66:30-66:31::x :: "a"
66:32-66:33::y :: "{VV : a | x <= VV}"
66:34-66:38::tree :: "(Data.Heap.Binominal.Tree {VV : a | y <= VV})"
76:1-76:7::Data.Heap.Binominal.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
76:10-76:11::x :: "a"
79:1-79:5::Data.Heap.Binominal.link :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree a) -> (Data.Heap.Binominal.Tree a)"
79:6-79:8::t1 :: "(Data.Heap.Binominal.Tree a)"
79:49-79:51::t2 :: "(Data.Heap.Binominal.Tree a)"
80:5-80:7::ds_d3ek :: "a"
80:11-80:13::ds_d3en :: "a"
81:9-81:22::t2BoundedByX2 :: "(Data.Heap.Binominal.Tree a)"
81:25-81:55::_ :: "(Data.Heap.Binominal.Tree a)"
81:53-81:55::lq_anf$##7205759403792806130 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
82:9-82:22::t2BoundedByX1 :: "(Data.Heap.Binominal.Tree a)"
82:25-82:73::_ :: "(Data.Heap.Binominal.Tree a)"
82:54-82:56::ds_d3ek :: "a"
82:57-82:59::ds_d3en :: "a"
82:60-82:73::t2BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2BoundedByX2}"
83:10-83:16::lq_anf$##7205759403792806139 :: "GHC.Types.Int"
83:11-83:13::ds_d3ej :: "{v : GHC.Types.Int | v >= 0}"
83:14-83:15::lq_anf$##7205759403792806138 :: "GHC.Types.Int"
83:17-83:19::ds_d3ek :: "a"
83:20-83:39::lq_anf$##7205759403792806140 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t2BoundedByX1}"
83:21-83:34::t2BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2BoundedByX1}"
83:35-83:38::ds_d3el :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
85:9-85:22::t1BoundedByX1 :: "(Data.Heap.Binominal.Tree a)"
85:25-85:55::_ :: "(Data.Heap.Binominal.Tree a)"
85:53-85:55::lq_anf$##7205759403792806129 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
86:9-86:22::t1BoundedByX2 :: "(Data.Heap.Binominal.Tree a)"
86:25-86:73::_ :: "(Data.Heap.Binominal.Tree a)"
86:54-86:56::ds_d3en :: "a"
86:57-86:59::ds_d3ek :: "a"
86:60-86:73::t1BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1BoundedByX1}"
87:12-87:18::lq_anf$##7205759403792806135 :: "GHC.Types.Int"
87:13-87:15::ds_d3em :: "{v : GHC.Types.Int | v >= 0}"
87:16-87:17::lq_anf$##7205759403792806134 :: "GHC.Types.Int"
87:19-87:21::ds_d3en :: "a"
87:22-87:41::lq_anf$##7205759403792806136 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t1BoundedByX2}"
87:23-87:36::t1BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1BoundedByX2}"
87:37-87:40::ds_d3eo :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
91:1-91:6::Data.Heap.Binominal.empty :: "forall a . (Data.Heap.Binominal.Heap a)"
96:1-96:5::Data.Heap.Binominal.null :: "forall a . (Data.Heap.Binominal.Heap a) -> GHC.Types.Bool"
100:1-100:10::Data.Heap.Binominal.singleton :: "forall a . a -> (Data.Heap.Binominal.Heap a)"
100:11-100:12::x :: "a"
100:21-100:32::lq_anf$##7205759403792806183 :: "{v : (Data.Heap.Binominal.Tree a) | root v == x}"
100:26-100:27::lq_anf$##7205759403792806181 :: "GHC.Types.Int"
100:28-100:29::x :: "{VV : a | VV == x}"
100:30-100:32::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0}"
112:1-112:7::Data.Heap.Binominal.sumNat :: "{VV : GHC.Types.Int | VV >= 0} -> {VV : GHC.Types.Int | VV >= 0} -> {VV : GHC.Types.Int | VV >= 0}"
112:8-112:9::x :: "{VV : GHC.Types.Int | VV >= 0}"
112:10-112:11::y :: "{VV : GHC.Types.Int | VV >= 0}"
112:14-112:15::x :: "{v : GHC.Types.Int | v >= 0\n                     && v == x}"
112:18-112:19::y :: "{v : GHC.Types.Int | v >= 0\n                     && v == y}"
116:1-116:11::Data.Heap.Binominal.sumNatList :: "[{VV : GHC.Types.Int | VV >= 0}] -> {VV : GHC.Types.Int | VV >= 0}"
116:17-116:18::lq_anf$##7205759403792806187 :: "{v : GHC.Prim.Int# | v == 0}"
117:21-117:45::Data.Heap.Binominal.sumNat :: "{v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Int | v >= 0}"
117:28-117:29::x :: "{v : GHC.Types.Int | v >= 0\n                     && v == x}"
117:30-117:45::lq_anf$##7205759403792806188 :: "{v : GHC.Types.Int | v >= 0}"
117:42-117:44::xs :: "{v : [{v : GHC.Types.Int | v >= 0}] | len v >= 0\n                                      && v == xs}"
134:1-134:7::Data.Heap.Binominal.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\na -> (Data.Heap.Binominal.Heap a) -> (Data.Heap.Binominal.Heap a)"
134:8-134:9::x :: "a"
134:36-134:49::lq_anf$##7205759403792806151 :: "{v : (Data.Heap.Binominal.Tree a) | root v == x}"
134:42-134:43::lq_anf$##7205759403792806149 :: "GHC.Types.Int"
134:44-134:45::x :: "{VV : a | VV == x}"
134:46-134:48::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0}"
138:1-138:8::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Tree a) -> [(Data.Heap.Binominal.Tree a)] -> [(Data.Heap.Binominal.Tree a)]"
138:9-138:10::t :: "(Data.Heap.Binominal.Tree a)"
138:16-138:19::lq_anf$##7205759403792806142 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v == 0}"
138:17-138:18::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
140:5-140:11::lq_anf$##7205759403792806143 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t}"
140:10-140:11::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
140:14-140:21::lq_anf$##7205759403792806144 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t'}"
140:19-140:21::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
140:24-140:25::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
140:28-140:30::ds_d3er :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
141:24-141:47::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Tree a) -> [(Data.Heap.Binominal.Tree a)] -> [(Data.Heap.Binominal.Tree a)]"
141:32-141:43::lq_anf$##7205759403792806147 :: "(Data.Heap.Binominal.Tree a)"
141:38-141:39::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
141:40-141:42::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
141:44-141:47::ts' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts'}"
145:1-145:9::Data.Heap.Binominal.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n[a] -> (Data.Heap.Binominal.Heap a)"
145:19-145:32::lq_anf$##7205759403792806177 :: "(Data.Heap.Binominal.Heap a) -> a -> (Data.Heap.Binominal.Heap a)"
145:25-145:31::lq_anf$##7205759403792806176 :: "a -> (Data.Heap.Binominal.Heap a) -> (Data.Heap.Binominal.Heap a)"
145:33-145:38::_ :: "forall a . (Data.Heap.Binominal.Heap a)"
185:1-185:8::Data.Heap.Binominal.minimum :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Heap a) -> (GHC.Maybe.Maybe a)"
185:21-185:25::_ :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> {VV : a | VV == root x1}"
185:28-185:31::_ :: "forall a b . x1:(a, b) -> {VV : a | VV == fst x1}"
185:36-185:49::lq_anf$##7205759403792806206 :: "(GHC.Maybe.Maybe ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]))"
199:1-199:10::Data.Heap.Binominal.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Heap a) -> (Data.Heap.Binominal.Heap a)"
200:8-200:21::lq_anf$##7205759403792806208 :: "(GHC.Maybe.Maybe ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]))"
201:33-201:38::_ :: "forall a . (Data.Heap.Binominal.Heap a)"
202:33-202:64::lq_anf$##7205759403792806213 :: "[(Data.Heap.Binominal.Tree a)]"
202:46-202:59::lq_anf$##7205759403792806212 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v == len ts1}"
202:55-202:58::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts1}"
202:60-202:63::ts2 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts2}"
206:1-206:11::Data.Heap.Binominal.deleteMin2 :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Heap a) -> (GHC.Maybe.Maybe (a, (Data.Heap.Binominal.Heap a)))"
206:24-206:31::_ :: "forall a . {v : (GHC.Maybe.Maybe a) | isJust v <=> false}"
207:24-207:48::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Bool> .\nx1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                     && x_Tuple21 v == x1\n                                                                                     && snd v == x2\n                                                                                     && fst v == x1}"
207:26-207:27::m :: "a"
207:32-207:33::m :: "{VV : a | VV == m}"
207:35-207:46::lq_anf$##7205759403792806216 :: "(Data.Heap.Binominal.Heap a)"
207:45-207:46::ds_d3ft :: "(Data.Heap.Binominal.Heap a)"
207:53-207:62::lq_anf$##7205759403792806218 :: "(GHC.Maybe.Maybe a)"
207:61-207:62::ds_d3ft :: "(Data.Heap.Binominal.Heap a)"
211:1-211:11::Data.Heap.Binominal.deleteMin' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n[(Data.Heap.Binominal.Tree a)] -> (GHC.Maybe.Maybe ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]))"
211:17-211:24::_ :: "forall a . {v : (GHC.Maybe.Maybe a) | isJust v <=> false}"
213:8-213:21::lq_anf$##7205759403792806190 :: "(GHC.Maybe.Maybe ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]))"
213:19-213:21::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts}"
214:16-214:28::GHC.Maybe.Just :: "forall a .\nx1:a -> {v : (GHC.Maybe.Maybe a) | fromJust v == x1\n                                   && (isJust v <=> true)}"
214:21-214:28::lq_anf$##7205759403792806193 :: "{v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]) | x_Tuple21 v == t\n                                                                      && fst v == t}"
214:22-214:23::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
214:25-214:27::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0}"
216:10-216:16::lq_anf$##7205759403792806195 :: "{VV : a | VV == root t}"
216:15-216:16::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
216:19-216:26::lq_anf$##7205759403792806196 :: "{VV : a | VV == root t'}"
216:24-216:26::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
217:12-217:24::GHC.Maybe.Just :: "forall a .\nx1:a -> {v : (GHC.Maybe.Maybe a) | fromJust v == x1\n                                   && (isJust v <=> true)}"
217:17-217:24::lq_anf$##7205759403792806201 :: "{v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]) | x_Tuple22 v == ts\n                                                                      && x_Tuple21 v == t\n                                                                      && snd v == ts\n                                                                      && fst v == t}"
217:18-217:19::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
217:21-217:23::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts}"
218:12-218:28::GHC.Maybe.Just :: "forall a .\nx1:a -> {v : (GHC.Maybe.Maybe a) | fromJust v == x1\n                                   && (isJust v <=> true)}"
218:17-218:28::lq_anf$##7205759403792806200 :: "{v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree a)]) | x_Tuple21 v == t'\n                                                                      && fst v == t'}"
218:18-218:20::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
218:22-218:23::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
218:24-218:27::ts' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts'}"
229:1-229:6::Data.Heap.Binominal.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Heap a) -> (Data.Heap.Binominal.Heap a) -> (Data.Heap.Binominal.Heap a)"
233:1-233:7::Data.Heap.Binominal.merge' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n[(Data.Heap.Binominal.Tree a)] -> [(Data.Heap.Binominal.Tree a)] -> [(Data.Heap.Binominal.Tree a)]"
233:8-233:11::ts1 :: "[(Data.Heap.Binominal.Tree a)]"
233:17-233:20::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts1}"
234:17-234:20::ds_d3eI :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
236:5-236:12::lq_anf$##7205759403792806158 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t1}"
236:10-236:12::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
236:15-236:22::lq_anf$##7205759403792806159 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t2}"
236:20-236:22::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
236:25-236:27::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
236:30-236:45::lq_anf$##7205759403792806169 :: "[(Data.Heap.Binominal.Tree a)]"
236:37-236:41::ts1' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts1'}"
236:42-236:45::ds_d3eI :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0}"
237:5-237:12::lq_anf$##7205759403792806162 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t2}"
237:10-237:12::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
237:15-237:22::lq_anf$##7205759403792806163 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t1}"
237:20-237:22::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
237:25-237:27::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
237:30-237:45::lq_anf$##7205759403792806168 :: "[(Data.Heap.Binominal.Tree a)]"
237:37-237:40::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts1}"
237:41-237:45::ts2' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts2'}"
238:25-238:64::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Binominal.Tree a) -> [(Data.Heap.Binominal.Tree a)] -> [(Data.Heap.Binominal.Tree a)]"
238:33-238:45::lq_anf$##7205759403792806166 :: "(Data.Heap.Binominal.Tree a)"
238:39-238:41::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
238:42-238:44::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
238:46-238:64::lq_anf$##7205759403792806167 :: "[(Data.Heap.Binominal.Tree a)]"
238:54-238:58::ts1' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts1'}"
238:59-238:63::ts2' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == ts2'}"