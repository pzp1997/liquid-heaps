1:1-1:1::Data.Heap.Binominal.$trModule :: "GHC.Types.Module"
44:1-44:12::Data.Heap.Binominal.sumSizeList :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {VV : GHC.Types.Int | VV == sumSizeList x1\n                                                           && VV >= 0\n                                                           && len x1 <= VV}"
44:18-44:19::lq_anf$##7205759403792805086 :: "{v : GHC.Prim.Int# | v == 0}"
45:22-45:28::lq_anf$##7205759403792805087 :: "{v : GHC.Types.Int | 1 <= v\n                     && v == 1 + sumSizeList (subtrees x)\n                     && v == size x}"
45:27-45:28::x :: "{v : (Data.Heap.Binominal.Tree a) | v == x}"
45:31-45:45::lq_anf$##7205759403792805088 :: "{v : GHC.Types.Int | v == sumSizeList xs\n                     && v >= 0\n                     && len xs <= v}"
45:43-45:45::xs :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && v == xs}"
50:1-50:9::Data.Heap.Binominal.heapSize :: "forall a .\nx1:(Data.Heap.Binominal.Heap a) -> {VV : GHC.Types.Int | VV == heapSize x1\n                                                         && VV >= 0\n                                                         && len (unheap x1) <= VV}"
50:22-50:36::Data.Heap.Binominal.sumSizeList :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {VV : GHC.Types.Int | VV == sumSizeList x1\n                                                           && VV >= 0\n                                                           && len x1 <= VV}"
50:34-50:36::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
79:1-79:28::Data.Heap.Binominal.treeIsBoundedByItsRootLemma :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> {VV : (Data.Heap.Binominal.Tree {VV : a | root x1 <= VV}) | size VV == size x1}"
80:3-80:46::Data.Heap.Binominal.Node :: "forall a .\nx1:{v : GHC.Types.Int | v >= 0} -> x2:a -> x3:[(Data.Heap.Binominal.Tree {VV : a | x2 <= VV})] -> x4:{v : GHC.Types.Int | 1 <= v\n                                                                                                                          && v == 1 + sumSizeList x3} -> {v : (Data.Heap.Binominal.Tree a) | size v == x4\n                                                                                                                                                                                             && subtrees v == x3\n                                                                                                                                                                                             && root v == x2\n                                                                                                                                                                                             && rank v == x1}"
80:14-80:15::ds_d2V8 :: "{v : GHC.Types.Int | v >= 0}"
80:22-80:23::ds_d2V9 :: "a"
80:34-80:36::ds_d2Va :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
80:43-80:45::ds_d2Vb :: "{v : GHC.Types.Int | 1 <= v}"
85:1-85:29::Data.Heap.Binominal.boundedTreeTransitivityLemma :: "forall a .\nx1:a -> x2:{VV : a | x1 <= VV} -> x3:(Data.Heap.Binominal.Tree {VV : a | x2 <= VV}) -> {VV : (Data.Heap.Binominal.Tree {VV : a | x1 <= VV}) | size VV == size x3}"
85:30-85:31::x :: "a"
85:32-85:33::y :: "{VV : a | x <= VV}"
85:34-85:38::tree :: "(Data.Heap.Binominal.Tree {VV : a | y <= VV})"
89:1-89:33::Data.Heap.Binominal.boundedTreeListTransitivityLemma :: "forall a .\nx1:a -> x2:{VV : a | x1 <= VV} -> x3:[(Data.Heap.Binominal.Tree {VV : a | x2 <= VV})] -> {v : [(Data.Heap.Binominal.Tree {VV : a | x1 <= VV})] | sumSizeList v == sumSizeList x3}"
89:34-89:35::x :: "a"
89:36-89:37::y :: "{VV : a | x <= VV}"
89:38-89:40::ts :: "[(Data.Heap.Binominal.Tree {VV : a | y <= VV})]"
93:1-93:17::Data.Heap.Binominal.sublistSizeLemma :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> x2:[(Data.Heap.Binominal.Tree a)] -> {VV : GHC.Types.Int | VV >= 0\n                                                                                              && VV == size x1 + sumSizeList x2\n                                                                                              && sumSizeList x2 < VV}"
93:18-93:19::x :: "(Data.Heap.Binominal.Tree a)"
93:20-93:22::xs :: "[(Data.Heap.Binominal.Tree a)]"
94:3-94:22::lq_anf$##7205759403792805158 :: "GHC.Types.Int -> GHC.Types.Int"
94:10-94:22::lq_anf$##7205759403792805157 :: "GHC.Types.Bool"
94:11-94:12::lq_anf$##7205759403792805155 :: "GHC.Types.Int"
94:15-94:21::lq_anf$##7205759403792805156 :: "{v : GHC.Types.Int | 1 <= v\n                     && v == 1 + sumSizeList (subtrees x)\n                     && v == size x}"
94:20-94:21::x :: "{v : (Data.Heap.Binominal.Tree a) | v == x}"
95:3-95:23::lq_anf$##7205759403792805160 :: "{v : GHC.Types.Int | v >= 0}"
95:15-95:23::lq_anf$##7205759403792805159 :: "{v : [(Data.Heap.Binominal.Tree a)] | tail v == xs\n                                      && head v == x\n                                      && listElts v == Set_cup (Set_sng x) (listElts xs)\n                                      && len v == 1 + len xs\n                                      && sumSizeList v == size x + sumSizeList xs}"
95:16-95:17::x :: "{v : (Data.Heap.Binominal.Tree a) | v == x}"
95:20-95:22::xs :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == xs}"
102:1-102:23::Data.Heap.Binominal.subtreeTransitiveLemma :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> [{t : (Data.Heap.Binominal.Tree a) | size t <= x1}] -> x3:{VV : GHC.Types.Int | VV >= 0\n                                                                                                                     && x1 <= VV} -> [{t : (Data.Heap.Binominal.Tree a) | size t <= x3}]"
102:26-102:28::ts :: "[(Data.Heap.Binominal.Tree a)]"
106:1-106:14::Data.Heap.Binominal.consTreeLemma :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> {VV : (Data.Heap.Binominal.Tree a) | size VV <= x1} -> [{t : (Data.Heap.Binominal.Tree a) | size t <= x1}] -> [{t : (Data.Heap.Binominal.Tree a) | size t <= x1}]"
106:17-106:18::t :: "(Data.Heap.Binominal.Tree a)"
106:19-106:21::ts :: "[(Data.Heap.Binominal.Tree a)]"
106:24-106:25::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
106:28-106:30::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
110:1-110:24::Data.Heap.Binominal.boundedSizeSubtreeLemma :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> [{t : (Data.Heap.Binominal.Tree a) | size t <= sumSizeList x1}]"
110:30-110:32::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
112:7-112:9::ih :: "[{v : (Data.Heap.Binominal.Tree a) | size v <= sumSizeList ts}]"
112:12-112:38::Data.Heap.Binominal.boundedSizeSubtreeLemma :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> [{t : (Data.Heap.Binominal.Tree a) | size t <= sumSizeList x1}]"
112:36-112:38::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
113:7-113:14::sizetts :: "{v : GHC.Types.Int | v >= 0\n                     && v == size t + sumSizeList ts\n                     && sumSizeList ts < v}"
113:17-113:38::_ :: "{v : GHC.Types.Int | v >= 0\n                     && v == size t + sumSizeList ts\n                     && sumSizeList ts < v}"
113:34-113:35::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
113:36-113:38::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
114:7-114:13::sizets :: "{v : GHC.Types.Int | v == sumSizeList ts\n                     && v >= 0\n                     && len ts <= v}"
114:16-114:30::Data.Heap.Binominal.sumSizeList :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {VV : GHC.Types.Int | VV == sumSizeList x1\n                                                           && VV >= 0\n                                                           && len x1 <= VV}"
114:28-114:30::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
115:7-115:22::refinedSubtrees :: "[{v : (Data.Heap.Binominal.Tree a) | size v <= sizetts}]"
115:25-115:65::_ :: "[{v : (Data.Heap.Binominal.Tree a) | size v <= sizetts}]"
115:48-115:54::sizets :: "{v : GHC.Types.Int | v == sumSizeList ts\n                     && v >= 0\n                     && len ts <= v\n                     && v == sizets}"
115:55-115:57::ih :: "{v : [{v : (Data.Heap.Binominal.Tree a) | size v <= sumSizeList ts}] | len v >= 0\n                                                                       && sumSizeList v >= 0\n                                                                       && v == ih}"
115:58-115:65::sizetts :: "{v : GHC.Types.Int | v >= 0\n                     && v == size t + sumSizeList ts\n                     && sumSizeList ts < v\n                     && v == sizetts}"
116:17-116:24::sizetts :: "{v : GHC.Types.Int | v >= 0\n                     && v == size t + sumSizeList ts\n                     && sumSizeList ts < v\n                     && v == sizetts}"
116:25-116:26::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
116:27-116:42::refinedSubtrees :: "{v : [{v : (Data.Heap.Binominal.Tree a) | size v <= sizetts}] | len v >= 0\n                                                                && sumSizeList v >= 0\n                                                                && v == refinedSubtrees}"
125:1-125:7::Data.Heap.Binominal.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
125:10-125:11::x :: "a"
129:1-129:18::Data.Heap.Binominal.assertBoundedTree :: "forall a b .\nx1:a -> (Data.Heap.Binominal.Tree {VV : a | x1 <= VV}) -> b -> b"
129:23-129:24::x :: "a"
133:1-133:22::Data.Heap.Binominal.assertBoundedTreeList :: "forall a b .\nx1:a -> [(Data.Heap.Binominal.Tree {VV : a | x1 <= VV})] -> b -> b"
133:27-133:28::x :: "a"
137:1-137:5::Data.Heap.Binominal.link :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Tree a) -> x3:(Data.Heap.Binominal.Tree a) -> {v : (Data.Heap.Binominal.Tree a) | size v == size x2 + size x3}"
137:6-137:8::t1 :: "(Data.Heap.Binominal.Tree a)"
137:59-137:61::t2 :: "(Data.Heap.Binominal.Tree a)"
138:5-138:7::ds_d2Vz :: "a"
138:11-138:13::ds_d2VD :: "a"
139:9-139:22::t2BoundedByX2 :: "(Data.Heap.Binominal.Tree a)"
139:25-139:55::_ :: "(Data.Heap.Binominal.Tree a)"
139:53-139:55::lq_anf$##7205759403792805095 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
140:9-140:22::t2BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t2BoundedByX2}"
140:25-140:73::_ :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t2BoundedByX2}"
140:54-140:56::ds_d2Vz :: "a"
140:57-140:59::ds_d2VD :: "a"
140:60-140:73::t2BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2BoundedByX2}"
141:10-141:16::lq_anf$##7205759403792805105 :: "GHC.Types.Int"
141:11-141:13::ds_d2Vy :: "{v : GHC.Types.Int | v >= 0}"
141:14-141:15::lq_anf$##7205759403792805104 :: "GHC.Types.Int"
141:17-141:19::ds_d2Vz :: "a"
141:20-141:39::lq_anf$##7205759403792805106 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t2BoundedByX1}"
141:21-141:34::t2BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t2BoundedByX2\n                                    && v == t2BoundedByX1}"
141:35-141:38::ds_d2VA :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
141:40-141:51::lq_anf$##7205759403792805107 :: "GHC.Types.Int"
141:41-141:44::ds_d2VB :: "{v : GHC.Types.Int | 1 <= v}"
141:47-141:50::ds_d2VF :: "{v : GHC.Types.Int | 1 <= v}"
143:9-143:22::t1BoundedByX1 :: "(Data.Heap.Binominal.Tree a)"
143:25-143:55::_ :: "(Data.Heap.Binominal.Tree a)"
143:53-143:55::lq_anf$##7205759403792805094 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
144:9-144:22::t1BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t1BoundedByX1}"
144:25-144:73::_ :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t1BoundedByX1}"
144:54-144:56::ds_d2VD :: "a"
144:57-144:59::ds_d2Vz :: "a"
144:60-144:73::t1BoundedByX1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1BoundedByX1}"
145:10-145:16::lq_anf$##7205759403792805100 :: "GHC.Types.Int"
145:11-145:13::ds_d2VC :: "{v : GHC.Types.Int | v >= 0}"
145:14-145:15::lq_anf$##7205759403792805099 :: "GHC.Types.Int"
145:17-145:19::ds_d2VD :: "a"
145:20-145:39::lq_anf$##7205759403792805101 :: "{v : [(Data.Heap.Binominal.Tree a)] | head v == t1BoundedByX2}"
145:21-145:34::t1BoundedByX2 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t1BoundedByX1\n                                    && v == t1BoundedByX2}"
145:35-145:38::ds_d2VE :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
145:40-145:51::lq_anf$##7205759403792805102 :: "GHC.Types.Int"
145:41-145:44::ds_d2VB :: "{v : GHC.Types.Int | 1 <= v}"
145:47-145:50::ds_d2VF :: "{v : GHC.Types.Int | 1 <= v}"
149:1-149:6::Data.Heap.Binominal.empty :: "forall a . {v : (Data.Heap.Binominal.Heap a) | heapSize v == 0}"
149:14-149:16::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
153:1-153:5::Data.Heap.Binominal.null :: "forall a .\nx1:(Data.Heap.Binominal.Heap a) -> {v : GHC.Types.Bool | v <=> heapSize x1 == 0}"
153:6-153:7::h :: "(Data.Heap.Binominal.Heap a)"
153:10-153:20::lq_anf$##7205759403792805090 :: "{v : GHC.Types.Int | v == heapSize h\n                     && v >= 0\n                     && len (unheap h) <= v}"
153:19-153:20::h :: "{v : (Data.Heap.Binominal.Heap a) | heapSize v >= 0\n                                    && v == h}"
153:24-153:25::lq_anf$##7205759403792805092 :: "GHC.Types.Int"
157:1-157:10::Data.Heap.Binominal.singleton :: "forall a .\na -> {v : (Data.Heap.Binominal.Heap a) | heapSize v == 1}"
157:11-157:12::x :: "a"
157:20-157:35::lq_anf$##7205759403792805172 :: "[(Data.Heap.Binominal.Tree a)]"
157:21-157:34::lq_anf$##7205759403792805170 :: "{v : (Data.Heap.Binominal.Tree a) | root v == x}"
157:26-157:27::lq_anf$##7205759403792805166 :: "GHC.Types.Int"
157:28-157:29::x :: "{VV : a | VV == x}"
157:30-157:32::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
157:33-157:34::lq_anf$##7205759403792805169 :: "GHC.Types.Int"
169:1-169:7::Data.Heap.Binominal.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\na -> x3:(Data.Heap.Binominal.Heap a) -> {v : (Data.Heap.Binominal.Heap a) | 1 + heapSize x3 == heapSize v}"
169:8-169:9::x :: "a"
169:22-169:55::Data.Heap.Binominal.Heap :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {v : (Data.Heap.Binominal.Heap a) | unheap v == x1\n                                                                         && heapSize v == sumSizeList x1}"
169:27-169:55::lq_anf$##7205759403792805122 :: "[(Data.Heap.Binominal.Tree a)]"
169:36-169:51::lq_anf$##7205759403792805121 :: "{v : (Data.Heap.Binominal.Tree a) | root v == x}"
169:42-169:43::lq_anf$##7205759403792805117 :: "GHC.Types.Int"
169:44-169:45::x :: "{VV : a | VV == x}"
169:46-169:48::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
169:49-169:50::lq_anf$##7205759403792805120 :: "GHC.Types.Int"
169:52-169:54::ts :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
173:1-173:8::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Tree a) -> x3:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == size x2 + sumSizeList x3}"
173:9-173:10::t :: "(Data.Heap.Binominal.Tree a)"
173:16-173:19::lq_anf$##7205759403792805109 :: "{v : [(Data.Heap.Binominal.Tree a)] | Set_emp (listElts v)\n                                      && len v == 0\n                                      && sumSizeList v == 0}"
173:17-173:18::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
175:5-175:11::lq_anf$##7205759403792805110 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t}"
175:10-175:11::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
175:14-175:21::lq_anf$##7205759403792805111 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t'}"
175:19-175:21::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
175:24-175:25::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
175:28-175:30::ds_d2VI :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
176:24-176:47::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Tree a) -> x3:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == size x2 + sumSizeList x3}"
176:32-176:43::lq_anf$##7205759403792805114 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t + size t'}"
176:38-176:39::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
176:40-176:42::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
176:44-176:47::ts' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts'}"
181:1-181:4::Data.Heap.Binominal.len :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | VV == len x1\n                                && VV >= 0}"
181:10-181:11::lq_anf$##7205759403792805174 :: "{v : GHC.Prim.Int# | v == 0}"
182:14-182:15::lq_anf$##7205759403792805176 :: "GHC.Types.Int"
182:18-182:24::lq_anf$##7205759403792805177 :: "{v : GHC.Types.Int | v == len xs\n                     && v >= 0}"
182:22-182:24::xs :: "{v : [a] | sumSizeList v >= 0\n           && len v >= 0\n           && v == xs}"
186:1-186:9::Data.Heap.Binominal.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {v : (Data.Heap.Binominal.Heap a) | heapSize v == len x2}"
186:15-186:20::_ :: "forall a . {v : (Data.Heap.Binominal.Heap a) | heapSize v == 0}"
187:19-187:41::$dOrd_a2H4 :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a2H4}"
187:26-187:27::x :: "{VV : a | VV == x}"
187:28-187:41::lq_anf$##7205759403792805164 :: "{v : (Data.Heap.Binominal.Heap a) | heapSize v == len xs}"
187:38-187:40::xs :: "{v : [a] | len v >= 0\n           && sumSizeList v >= 0\n           && v == xs}"
229:1-229:8::Data.Heap.Binominal.minimum :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)} -> a"
229:11-229:15::_ :: "forall a .\nx1:(Data.Heap.Binominal.Tree a) -> {VV : a | VV == root x1}"
229:18-229:21::_ :: "forall a b . x1:(a, b) -> {VV : a | VV == fst x1}"
229:24-229:34::lq_anf$##7205759403792805186 :: "x1:{v : [(Data.Heap.Binominal.Tree a)] | 0 < len v} -> {v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree {VV : a | root (fst x15) <= VV})]) | size (fst v) + sumSizeList (snd v) == sumSizeList x1}"
229:37-229:51::_ :: "forall a .\nx1:{v : (Data.Heap.Binominal.Heap a) | 0 < len (unheap v)} -> {v : [(Data.Heap.Binominal.Tree a)] | 0 < len v\n                                                                                                    && sumSizeList v == heapSize x1}"
235:1-235:16::Data.Heap.Binominal.reverseHeapList :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList x1}"
235:17-235:19::xs :: "[(Data.Heap.Binominal.Tree a)]"
235:41-235:43::xs :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == xs}"
235:44-235:46::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
239:1-239:19::Data.Heap.Binominal.reverseHeapListAux :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> x2:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList x1 + sumSizeList x2}"
239:23-239:26::acc :: "[(Data.Heap.Binominal.Tree a)]"
239:29-239:32::acc :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == acc}"
240:33-240:62::Data.Heap.Binominal.reverseHeapListAux :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> x2:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList x1 + sumSizeList x2}"
240:52-240:54::xs :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == xs}"
240:55-240:62::lq_anf$##7205759403792805179 :: "{v : [(Data.Heap.Binominal.Tree a)] | tail v == acc\n                                      && head v == x\n                                      && listElts v == Set_cup (Set_sng x) (listElts acc)\n                                      && len v == 1 + len acc\n                                      && sumSizeList v == size x + sumSizeList acc}"
240:56-240:57::x :: "{v : (Data.Heap.Binominal.Tree a) | v == x}"
240:58-240:61::acc :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == acc}"
244:1-244:15::Data.Heap.Binominal.unheapNonempty :: "forall a .\nx1:{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)} -> {v : [(Data.Heap.Binominal.Tree a)] | 0 < len v\n                                                                                                      && sumSizeList v == heapSize x1}"
244:34-244:36::lq_anf$##7205759403792805182 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts}"
248:1-248:10::Data.Heap.Binominal.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)} -> {v : (Data.Heap.Binominal.Heap a) | 1 + heapSize v == heapSize x2}"
248:11-248:12::h :: "{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)}"
249:31-249:60::lq_anf$##7205759403792805191 :: "((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree {VV : a | root (fst x9) <= VV})])"
249:42-249:60::lq_anf$##7205759403792805190 :: "{v : [(Data.Heap.Binominal.Tree a)] | 0 < len v\n                                      && sumSizeList v == heapSize h}"
249:58-249:59::h :: "{v : (Data.Heap.Binominal.Heap a) | 0 < len (unheap v)\n                                    && heapSize v >= 0\n                                    && v == h}"
250:8-250:42::lq_anf$##7205759403792805195 :: "[(Data.Heap.Binominal.Tree a)]"
250:16-250:37::lq_anf$##7205759403792805194 :: "{v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList ts1}"
250:33-250:36::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1}"
250:38-250:41::ts2 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts2}"
254:1-254:11::Data.Heap.Binominal.deleteMin2 :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)} -> {v : (a, (Data.Heap.Binominal.Heap {VV : a | fst v <= VV})) | 1 + heapSize (snd v) == heapSize x2}"
254:12-254:13::h :: "{VV : (Data.Heap.Binominal.Heap a) | 0 < len (unheap VV)}"
255:36-255:65::lq_anf$##7205759403792805197 :: "((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree {VV : a | root (fst x9) <= VV})])"
255:47-255:65::lq_anf$##7205759403792805196 :: "{v : [(Data.Heap.Binominal.Tree a)] | 0 < len v\n                                      && sumSizeList v == heapSize h}"
255:63-255:64::h :: "{v : (Data.Heap.Binominal.Heap a) | 0 < len (unheap v)\n                                    && heapSize v >= 0\n                                    && v == h}"
256:4-256:10::minElt :: "{VV : a | VV == minElt}"
256:12-256:51::lq_anf$##7205759403792805202 :: "(Data.Heap.Binominal.Heap a)"
256:17-256:51::lq_anf$##7205759403792805201 :: "[(Data.Heap.Binominal.Tree a)]"
256:25-256:46::lq_anf$##7205759403792805200 :: "{v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList ts1}"
256:42-256:45::ts1 :: "{v : [(Data.Heap.Binominal.Tree {VV : a | minElt <= VV})] | len v >= 0\n                                                            && sumSizeList v >= 0\n                                                            && v == ts1}"
256:47-256:50::ts2 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts2}"
260:1-260:11::Data.Heap.Binominal.deleteMin' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{v : [(Data.Heap.Binominal.Tree a)] | 0 < len v} -> {v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree {VV : a | root (fst v) <= VV})]) | size (fst v) + sumSizeList (snd v) == sumSizeList x2}"
260:18-260:25::lq_anf$##7205759403792805151 :: "{v : [(Data.Heap.Binominal.Tree a)] | Set_emp (listElts v)\n                                      && len v == 0\n                                      && sumSizeList v == 0}"
260:19-260:20::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
260:22-260:24::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
262:8-262:10::t' :: "(Data.Heap.Binominal.Tree a)"
262:12-262:15::ts' :: "{VV : [(Data.Heap.Binominal.Tree {VV : a | root t' <= VV})] | len VV >= 0}"
262:19-262:32::Data.Heap.Binominal.deleteMin' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{v : [(Data.Heap.Binominal.Tree a)] | 0 < len v} -> {v : ((Data.Heap.Binominal.Tree a), [(Data.Heap.Binominal.Tree {VV : a | root (fst v) <= VV})]) | size (fst v) + sumSizeList (snd v) == sumSizeList x2}"
262:30-262:32::ds_d2X9 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
263:7-263:8::x :: "{VV : a | VV == root t}"
263:11-263:17::_ :: "{VV : a | VV == root t}"
263:16-263:17::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
264:7-264:9::x' :: "{VV : a | VV == root t'}"
264:12-264:19::_ :: "{VV : a | VV == root t'}"
264:17-264:19::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
265:7-265:15::tBounded :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t <= VV}) | size v == size t}"
265:18-265:47::_ :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t <= VV}) | size v == size t}"
265:46-265:47::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
266:7-266:16::tBounded' :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t' <= VV}) | size v == size t'}"
266:19-266:49::_ :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t' <= VV}) | size v == size t'}"
266:47-266:49::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
267:6-267:7::x :: "{VV : a | VV == root t\n          && VV == x}"
267:10-267:12::x' :: "{VV : a | VV == root t'\n          && VV == x'}"
269:9-269:11::hd :: "{v : (Data.Heap.Binominal.Tree {VV : a | x <= VV}) | size v == size tBounded'}"
269:14-269:57::_ :: "{v : (Data.Heap.Binominal.Tree {VV : a | x <= VV}) | size v == size tBounded'}"
269:43-269:44::x :: "{VV : a | VV == root t\n          && VV == x}"
269:45-269:47::x' :: "{VV : a | VV == root t'\n          && VV == x'}"
269:48-269:57::tBounded' :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t' <= VV}) | size v == size t'\n                                                           && v == tBounded'}"
270:9-270:11::tl :: "{v : [(Data.Heap.Binominal.Tree {VV : a | x <= VV})] | sumSizeList v == sumSizeList ts'}"
270:14-270:55::_ :: "{v : [(Data.Heap.Binominal.Tree {VV : a | x <= VV})] | sumSizeList v == sumSizeList ts'}"
270:47-270:48::x :: "{VV : a | VV == root t\n          && VV == x}"
270:49-270:51::x' :: "{VV : a | VV == root t'\n          && VV == x'}"
270:52-270:55::ts' :: "{v : [(Data.Heap.Binominal.Tree {VV : a | root t' <= VV})] | len v >= 0\n                                                             && sumSizeList v >= 0\n                                                             && v == ts'}"
271:6-271:7::t :: "{v : (Data.Heap.Binominal.Tree a) | v == t}"
271:9-271:11::hd :: "{v : (Data.Heap.Binominal.Tree {VV : a | x <= VV}) | size v == size tBounded'\n                                                     && v == hd}"
271:12-271:14::tl :: "{v : [(Data.Heap.Binominal.Tree {VV : a | x <= VV})] | sumSizeList v == sumSizeList ts'\n                                                       && len v >= 0\n                                                       && sumSizeList v >= 0\n                                                       && v == tl}"
273:9-273:11::hd :: "{v : (Data.Heap.Binominal.Tree {VV : a | x' <= VV}) | size v == size tBounded}"
273:14-273:56::_ :: "{v : (Data.Heap.Binominal.Tree {VV : a | x' <= VV}) | size v == size tBounded}"
273:43-273:45::x' :: "{VV : a | VV == root t'\n          && VV == x'}"
273:46-273:47::x :: "{VV : a | VV == root t\n          && VV == x}"
273:48-273:56::tBounded :: "{v : (Data.Heap.Binominal.Tree {VV : a | root t <= VV}) | size v == size t\n                                                          && v == tBounded}"
274:6-274:8::t' :: "{v : (Data.Heap.Binominal.Tree a) | v == t'}"
274:10-274:12::hd :: "{v : (Data.Heap.Binominal.Tree {VV : a | x' <= VV}) | size v == size tBounded\n                                                      && v == hd}"
274:13-274:16::ts' :: "{v : [(Data.Heap.Binominal.Tree {VV : a | root t' <= VV})] | len v >= 0\n                                                             && sumSizeList v >= 0\n                                                             && v == ts'}"
287:1-287:6::Data.Heap.Binominal.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Heap a) -> x3:(Data.Heap.Binominal.Heap a) -> {VV : (Data.Heap.Binominal.Heap a) | heapSize VV == heapSize x2 + heapSize x3}"
287:31-287:52::Data.Heap.Binominal.Heap :: "forall a .\nx1:[(Data.Heap.Binominal.Tree a)] -> {v : (Data.Heap.Binominal.Heap a) | unheap v == x1\n                                                                         && heapSize v == sumSizeList x1}"
287:36-287:52::lq_anf$##7205759403792805143 :: "{v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList ts1 + sumSizeList ts2}"
287:44-287:47::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1}"
287:48-287:51::ts2 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts2}"
291:1-291:7::Data.Heap.Binominal.merge' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[(Data.Heap.Binominal.Tree a)] -> x3:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList x2 + sumSizeList x3}"
291:8-291:11::ts1 :: "[(Data.Heap.Binominal.Tree a)]"
291:17-291:20::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1}"
292:17-292:20::ds_d2W4 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
294:5-294:12::lq_anf$##7205759403792805127 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t1}"
294:10-294:12::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
294:15-294:22::lq_anf$##7205759403792805128 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t2}"
294:20-294:22::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
294:25-294:27::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
294:30-294:45::lq_anf$##7205759403792805138 :: "[(Data.Heap.Binominal.Tree a)]"
294:37-294:41::ts1' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1'}"
294:42-294:45::ds_d2W4 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0}"
295:5-295:12::lq_anf$##7205759403792805131 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t2}"
295:10-295:12::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
295:15-295:22::lq_anf$##7205759403792805132 :: "{v : GHC.Types.Int | v >= 0\n                     && v == rank t1}"
295:20-295:22::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
295:25-295:27::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
295:30-295:45::lq_anf$##7205759403792805137 :: "{v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList ts1 + sumSizeList ts2'}"
295:37-295:40::ts1 :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1}"
295:41-295:45::ts2' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts2'}"
296:25-296:64::Data.Heap.Binominal.insert' :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Tree a) -> x3:[(Data.Heap.Binominal.Tree a)] -> {v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == size x2 + sumSizeList x3}"
296:33-296:45::lq_anf$##7205759403792805135 :: "{v : (Data.Heap.Binominal.Tree a) | size v == size t1 + size t2}"
296:39-296:41::t1 :: "{v : (Data.Heap.Binominal.Tree a) | v == t1}"
296:42-296:44::t2 :: "{v : (Data.Heap.Binominal.Tree a) | v == t2}"
296:46-296:64::lq_anf$##7205759403792805136 :: "{v : [(Data.Heap.Binominal.Tree a)] | sumSizeList v == sumSizeList ts1' + sumSizeList ts2'}"
296:54-296:58::ts1' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts1'}"
296:59-296:63::ts2' :: "{v : [(Data.Heap.Binominal.Tree a)] | len v >= 0\n                                      && sumSizeList v >= 0\n                                      && v == ts2'}"
312:1-312:9::Data.Heap.Binominal.heapSort :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Binominal.Heap a) -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == heapSize x2}"
312:22-312:24::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                            && len v == 0\n                                            && sumSizeList v == 0}"
314:8-314:14::minElt :: "a"
314:16-314:18::h' :: "(Data.Heap.Binominal.Heap {VV : a | minElt <= VV\n                                    && VV >= minElt})"
314:22-314:34::_ :: "(a, (Data.Heap.Binominal.Heap {VV : a | fst x4 <= VV}))"
314:33-314:34::ds_d2XY :: "{v : (Data.Heap.Binominal.Heap a) | heapSize v >= 0}"
315:3-315:9::minElt :: "{VV : a | VV == minElt}"
315:12-315:23::lq_anf$##7205759403792805205 :: "{VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == heapSize h'}"
315:21-315:23::h' :: "{v : (Data.Heap.Binominal.Heap {VV : a | minElt <= VV\n                                         && VV >= minElt}) | heapSize v >= 0\n                                                             && v == h'}"
319:1-319:14::Data.Heap.Binominal.sortUsingHeap :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == len x2}"
319:17-319:25::lq_anf$##7205759403792805206 :: "x1:(Data.Heap.Binominal.Heap a) -> {v : [a]<\\x5 VV -> {VV : a | x5 <= VV}> | len v == heapSize x1}"
319:28-319:36::lq_anf$##7205759403792805207 :: "x1:[a] -> {v : (Data.Heap.Binominal.Heap a) | heapSize v == len x1}"