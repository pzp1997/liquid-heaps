<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/home/josh/Documents/HW/CIS673/cis673-proj/SkewHeap.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>{VV##3024 : GHC.Types.Module^"lq_tmp$x##3026" | $k_##3025}</span><span class='hs-comment'>{-|
  Skew Heap

  - the fun of programming
-}</span></a>
<span class=hs-linenum>  6: </span>
<span class=hs-linenum>  7: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.Heap.Skew</span> <span class='hs-keyword'>where</span> 
<span class=hs-linenum>  8: </span><span class='hs-comment'>--   -- * Data structures</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>--     Skew(..)</span>
<span class=hs-linenum> 10: </span><span class='hs-comment'>--   -- * Creating heaps</span>
<span class=hs-linenum> 11: </span><span class='hs-comment'>--   , empty</span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>--   , singleton</span>
<span class=hs-linenum> 13: </span><span class='hs-comment'>--   , insert</span>
<span class=hs-linenum> 14: </span><span class='hs-comment'>--   , fromList</span>
<span class=hs-linenum> 15: </span><span class='hs-comment'>--   -- * Converting to a list</span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>--   , toList</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>--   -- * Deleting</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>--   , deleteMin</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--   -- * Checking heaps</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>--   , null</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>--   -- * Helper functions</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>--   , merge</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>--   , minimum</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>--   , valid</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>--   , heapSort</span>
<span class=hs-linenum> 26: </span><span class='hs-comment'>--   ) where</span>
<span class=hs-linenum> 27: </span>
<span class=hs-linenum> 28: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Applicative</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 29: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldl'</span><span class='hs-layout'>,</span> <span class='hs-varid'>unfoldr</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 30: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span>
<span class=hs-linenum> 31: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>minimum</span><span class='hs-layout'>,</span> <span class='hs-varid'>maximum</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 32: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
<span class=hs-linenum> 33: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Set</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 34: </span>
<span class=hs-linenum> 35: </span><span class='hs-comment'>----------------------------------------------------------------</span>
<span class=hs-linenum> 36: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-conid'>X</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>n</span> <span class='hs-conop'>:</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>X</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 37: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>(</span><span class='hs-varid'>root</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>left</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-varid'>root</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-varid'>root</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 38: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Show</span>
<span class=hs-linenum> 39: </span>
<span class=hs-linenum> 40: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum> 41: </span>
<span class=hs-linenum> 42: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bounded</span> <span class='hs-conid'>Int</span> <span class='hs-num'>0</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 43: </span>
<span class=hs-linenum> 44: </span><span class='hs-comment'>{- Size of a heap -}</span>
<span class=hs-linenum> 45: </span>
<span class=hs-linenum> 46: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 47: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 48: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum> 49: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1177:(Data.Heap.Skew.Skew a) -&gt; {VV : GHC.Types.Int | VV == Data.Heap.Skew.size lq_tmp$x##1177
                                                                &amp;&amp; VV &gt;= 0}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1191 : GHC.Prim.Int# | lq_tmp$x##1191 == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum> 50: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1231 : GHC.Types.Int | lq_tmp$x##1231 == lq_anf$##7205759403792806366##d3jU}</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1238 : GHC.Types.Int | lq_tmp$x##1238 == Data.Heap.Skew.size l##a2rO
                                  &amp;&amp; lq_tmp$x##1238 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1246 : (Data.Heap.Skew.Skew {lq_tmp$x##1245 : a | ds_d3jn &lt;= lq_tmp$x##1245}) | lq_tmp$x##1246 == l##a2rO}</span><span class='hs-varid'>l</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1268 : GHC.Types.Int | lq_tmp$x##1268 == Data.Heap.Skew.size r##a2rP
                                  &amp;&amp; lq_tmp$x##1268 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1276 : (Data.Heap.Skew.Skew {lq_tmp$x##1275 : a | ds_d3jn &lt;= lq_tmp$x##1275}) | lq_tmp$x##1276 == r##a2rP}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum> 51: </span>
<span class=hs-linenum> 52: </span><span class='hs-comment'>-- -- {-| Empty heap.-}</span>
<span class=hs-linenum> 53: </span>
<span class=hs-linenum> 54: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r = 0 &amp;&amp; elts r = S.empty}</span><span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 55: </span><span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 56: </span><a class=annot href="#"><span class=annottext>forall a .
{r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r == 0
                               &amp;&amp; Data.Heap.Skew.elts r == Set_empty 0}</span><span class='hs-definition'>empty</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span><span class='hs-comment'>-- -- {- See if the heap is empty.-}</span>
<span class=hs-linenum> 59: </span>
<span class=hs-linenum> 60: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>null</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{b :</span> <span class='hs-conid'>Bool</span> <span class='hs-keyword'>| b &lt;=&gt; size s = 0}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 61: </span><span class='hs-definition'>null</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum> 62: </span><a class=annot href="#"><span class=annottext>forall t .
lq_tmp$x##1305:(Data.Heap.Skew.Skew t) -&gt; {b : GHC.Types.Bool | b &lt;=&gt; Data.Heap.Skew.size lq_tmp$x##1305 == 0}</span><span class='hs-definition'>null</span></a> <span class='hs-conid'>Leaf</span>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1318 : GHC.Types.Bool | lq_tmp$x##1318
                                   &amp;&amp; lq_tmp$x##1318 == GHC.Types.True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum> 63: </span><span class='hs-definition'>null</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1349 : GHC.Types.Bool | not lq_tmp$x##1349
                                   &amp;&amp; lq_tmp$x##1349 == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum> 64: </span>
<span class=hs-linenum> 65: </span><span class='hs-comment'>-- -- {-| Singleton heap.-}</span>
<span class=hs-linenum> 66: </span>
<span class=hs-linenum> 67: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>singleton</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r = 1 &amp;&amp; elts r = S.singleton x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 68: </span><span class='hs-definition'>singleton</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 69: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1354:a -&gt; {r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r == 1
                                                   &amp;&amp; Data.Heap.Skew.elts r == Set_sng lq_tmp$x##1354}</span><span class='hs-definition'>singleton</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1387 : a | lq_tmp$x##1387 == x##a2tJ}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>forall a .
{lq_tmp$x##1357 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.elts lq_tmp$x##1357 == Set_empty 0
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##1357 == 0}</span><span class='hs-conid'>Leaf</span></a> <a class=annot href="#"><span class=annottext>forall a .
{lq_tmp$x##1364 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.elts lq_tmp$x##1364 == Set_empty 0
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##1364 == 0}</span><span class='hs-conid'>Leaf</span></a>
<span class=hs-linenum> 70: </span>
<span class=hs-linenum> 71: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum> 72: </span>
<span class=hs-linenum> 73: </span><span class='hs-comment'>-- -- {-| Insertion. -}</span>
<span class=hs-linenum> 74: </span>
<span class=hs-linenum> 75: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>insert</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r = 1 + size s &amp;&amp; elts r = S.union (elts s) (S.singleton x)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 76: </span><span class='hs-definition'>insert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 77: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##2834:a -&gt; lq_tmp$x##2835:(Data.Heap.Skew.Skew a) -&gt; {r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r == 1 + Data.Heap.Skew.size lq_tmp$x##2835
                                                                                             &amp;&amp; Data.Heap.Skew.elts r == Set_cup (Data.Heap.Skew.elts lq_tmp$x##2835) (Set_sng lq_tmp$x##2834)}</span><span class='hs-definition'>insert</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>(Data.Heap.Skew.Skew a)</span><span class='hs-varid'>t</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>merge</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2841 : (Data.Heap.Skew.Skew {lq_tmp$x##2847 : a^"lq_tmp$x##2846" | $k_##2845[VV##2844:=lq_tmp$x##2847][lq_tmp$x##2843:=x##a2tK]}) | Data.Heap.Skew.size lq_tmp$x##2841 == 1
                                                                                                                                               &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2841 == Set_sng x##a2tK}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>singleton</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2848 : a | lq_tmp$x##2848 == x##a2tK}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2873 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size lq_tmp$x##2873 &gt;= 0
                                            &amp;&amp; lq_tmp$x##2873 == t##a2tL}</span><span class='hs-varid'>t</span></a>
<span class=hs-linenum> 78: </span>
<span class=hs-linenum> 79: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum> 80: </span>
<span class=hs-linenum> 81: </span><span class='hs-comment'>-- -- {-| Creating a heap from a list. -}</span>
<span class=hs-linenum> 82: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fromList</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>l</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r = len l &amp;&amp; elts r = S.fromList l}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 83: </span><span class='hs-definition'>fromList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 84: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##2895:[a] -&gt; {r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r == len lq_tmp$x##2895
                                                     &amp;&amp; Data.Heap.Skew.elts r == listElts lq_tmp$x##2895}</span><span class='hs-definition'>fromList</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
{lq_tmp$x##2923 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.elts lq_tmp$x##2923 == Set_empty 0
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2923 == 0}</span><span class='hs-conid'>Leaf</span></a>
<span class=hs-linenum> 85: </span><span class='hs-definition'>fromList</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3008 : (GHC.Classes.Ord a) | lq_tmp$x##3008 == $dOrd_a3cn}</span><span class='hs-varid'>insert</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3009 : a | lq_tmp$x##3009 == x##a2tM}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2971 : (Data.Heap.Skew.Skew {lq_tmp$x##2981 : a^"lq_tmp$x##2980" | $k_##2979[VV##2978:=lq_tmp$x##2981][lq_tmp$x##2975:=fix$36$$36$dOrd_a3cn][lq_tmp$x##2976:=xs##a2tN]}) | Data.Heap.Skew.size lq_tmp$x##2971 == len xs##a2tN
                                                                                                                                                                                      &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2971 == listElts xs##a2tN}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>fromList</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2987 : [a] | len lq_tmp$x##2987 &gt;= 0
                        &amp;&amp; lq_tmp$x##2987 == xs##a2tN}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 86: </span>
<span class=hs-linenum> 87: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum> 88: </span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>-- Stuff about toList, which is not quite done - Liquid Haskell cannot verify the set relation</span>
<span class=hs-linenum> 90: </span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>-- {-@ app :: l1:[a] -&gt; l2:[a] -&gt; {r: [a] | eltsList r = S.union (eltsList l1) (eltsList l2)} @-}</span>
<span class=hs-linenum> 92: </span><span class='hs-comment'>-- app :: [a] -&gt; [a] -&gt; [a]</span>
<span class=hs-linenum> 93: </span><span class='hs-comment'>-- app [] l2 = l2</span>
<span class=hs-linenum> 94: </span><span class='hs-comment'>-- app (x:t) l2 = x : (app t l2)</span>
<span class=hs-linenum> 95: </span>
<span class=hs-linenum> 96: </span><span class='hs-comment'>-- {-@ measure fst' @-}</span>
<span class=hs-linenum> 97: </span><span class='hs-comment'>-- fst' :: (a,b,c) -&gt; a</span>
<span class=hs-linenum> 98: </span><span class='hs-comment'>-- fst' (x, _, _) = x</span>
<span class=hs-linenum> 99: </span>
<span class=hs-linenum>100: </span><span class='hs-comment'>-- {-@ measure snd' @-}</span>
<span class=hs-linenum>101: </span><span class='hs-comment'>-- snd' :: (a,b,c) -&gt; b</span>
<span class=hs-linenum>102: </span><span class='hs-comment'>-- snd' (_, x, _) = x</span>
<span class=hs-linenum>103: </span>
<span class=hs-linenum>104: </span><span class='hs-comment'>-- {-@ measure trd' @-}</span>
<span class=hs-linenum>105: </span><span class='hs-comment'>-- trd' :: (a,b,c) -&gt; c</span>
<span class=hs-linenum>106: </span><span class='hs-comment'>-- trd' (_, _, x) = x</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span><span class='hs-comment'>-- {-@ eltsSubtreeLemma :: {s: Skew a | 0 &lt; size s} -&gt; {t: (a, Skew a, Skew a) | elts s = S.union (S.singleton (fst' t)) (S.union (elts (snd' t)) (elts (trd' t)))} @-}</span>
<span class=hs-linenum>109: </span><span class='hs-comment'>-- eltsSubtreeLemma :: Skew a -&gt; (a, Skew a, Skew a)</span>
<span class=hs-linenum>110: </span><span class='hs-comment'>-- eltsSubtreeLemma (Node x l r) = (x, l, r)</span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-comment'>-- -- I think Liquid Haskell should have enough info (especially with the lemma) to infer the set relation, not sure why it isn't</span>
<span class=hs-linenum>113: </span><span class='hs-comment'>-- -- The lemma causes it to not be obviously terminating, though that is easily fixable</span>
<span class=hs-linenum>114: </span><span class='hs-comment'>-- {-@ toList :: s:(Skew a) -&gt;  {l: [a] | len l = size s &amp;&amp; elts s = eltsList l} @-}</span>
<span class=hs-linenum>115: </span><span class='hs-comment'>-- toList :: Skew a -&gt; [a]</span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- toList Leaf = []</span>
<span class=hs-linenum>117: </span><span class='hs-comment'>-- toList n@(Node x l r) =</span>
<span class=hs-linenum>118: </span><span class='hs-comment'>--     let (y, l', r') = eltsSubtreeLemma n in</span>
<span class=hs-linenum>119: </span><span class='hs-comment'>--      y :  app (toList l') (toList r')</span>
<span class=hs-linenum>120: </span>
<span class=hs-linenum>121: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-comment'>-- -- {-| Finding the minimum element.-}</span>
<span class=hs-linenum>124: </span>
<span class=hs-linenum>125: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>minimum</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>126: </span><span class='hs-keyword'>{-@</span><span class='hs-definition'>minimum</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{s:</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| 0 &lt; size s}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>127: </span><span class='hs-definition'>minimum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>128: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1396:{VV : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size VV} -&gt; {VV : a | VV == Data.Heap.Skew.minimum lq_tmp$x##1396}</span><span class='hs-definition'>minimum</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1454 : a | lq_tmp$x##1454 == x##a2tO}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>129: </span>
<span class=hs-linenum>130: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum>131: </span>
<span class=hs-linenum>132: </span><span class='hs-comment'>-- -- {-| Deleting the minimum element. -}</span>
<span class=hs-linenum>133: </span>
<span class=hs-linenum>134: </span><span class='hs-keyword'>{-@</span><span class='hs-definition'>deleteMin</span> <span class='hs-keyglyph'>::</span>  <span class='hs-keyword'>{s:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| 0 &lt; size s}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r + 1 = size s}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>135: </span><span class='hs-definition'>deleteMin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>136: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##2704:{s : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size s} -&gt; {r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r + 1 == Data.Heap.Skew.size lq_tmp$x##2704}</span><span class='hs-definition'>deleteMin</span></a> <a class=annot href="#"><span class=annottext>{s : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size s}</span><span class='hs-varid'>t</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##2800:(a, b) -&gt; {lq_tmp$x##2797 : b | lq_tmp$x##2797 == snd lq_tmp$x##2800}</span><span class='hs-varid'>snd</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2777 : ({lq_tmp$x##2786 : a^"lq_tmp$x##2785" | $k_##2784[VV##2783:=lq_tmp$x##2786][lq_tmp$x##2780:=fix$36$$36$dOrd_a3bZ][lq_tmp$x##2781:=lq_anf$##7205759403792806408##d3kA]}, (Data.Heap.Skew.Skew {lq_tmp$x##2786 : a^"lq_tmp$x##2785" | $k_##2784[VV##2783:=lq_tmp$x##2786][lq_tmp$x##2780:=fix$36$$36$dOrd_a3bZ][lq_tmp$x##2781:=lq_anf$##7205759403792806408##d3kA]
                                                                                                                                                                                                                                                      &amp;&amp; fst lq_tmp$x##2777 &lt;= lq_tmp$x##2786})) | Data.Heap.Skew.size (snd lq_tmp$x##2777) + 1 == Data.Heap.Skew.size lq_anf$##7205759403792806408##d3kA
                                                                                                                                                                                                                                                                                                   &amp;&amp; Set_cup (Data.Heap.Skew.elts (snd lq_tmp$x##2777)) (Set_sng (fst lq_tmp$x##2777)) == Data.Heap.Skew.elts lq_anf$##7205759403792806408##d3kA}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>deleteMin2</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2790 : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size lq_tmp$x##2790
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2790 &gt;= 0
                                            &amp;&amp; lq_tmp$x##2790 == t##a2tP
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2790 &gt;= 0
                                            &amp;&amp; Data.Heap.Skew.right lq_tmp$x##2790 == ds_d3iB
                                            &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2790 == ds_d3iA
                                            &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2790 == ds_d3iz
                                            &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2790 == Set_cup (Set_sng ds_d3iz) (Set_cup (Data.Heap.Skew.elts ds_d3iA) (Data.Heap.Skew.elts ds_d3iB))
                                            &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2790 == ds_d3iz
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2790 == (1 + Data.Heap.Skew.size ds_d3iA) + Data.Heap.Skew.size ds_d3iB
                                            &amp;&amp; lq_tmp$x##2790 == Data.Heap.Skew.Node ds_d3iz ds_d3iA ds_d3iB
                                            &amp;&amp; Data.Heap.Skew.right lq_tmp$x##2790 == ds_d3iB
                                            &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2790 == ds_d3iA
                                            &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2790 == ds_d3iz
                                            &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2790 == Set_cup (Set_sng ds_d3iz) (Set_cup (Data.Heap.Skew.elts ds_d3iA) (Data.Heap.Skew.elts ds_d3iB))
                                            &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2790 == ds_d3iz
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2790 == (1 + Data.Heap.Skew.size ds_d3iA) + Data.Heap.Skew.size ds_d3iB
                                            &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2790 &gt;= 0
                                            &amp;&amp; lq_tmp$x##2790 == lq_anf$##7205759403792806408##d3kA}</span><span class='hs-varid'>t</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>137: </span>
<span class=hs-linenum>138: </span><span class='hs-comment'>--difference property does not work because the min could appear multiple times in the heap</span>
<span class=hs-linenum>139: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>deleteMin2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{s:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| 0 &lt; size s}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Skew</span> <span class='hs-keyword'>{x:</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| fst(r) &lt;= x}</span><span class='hs-layout'>)</span> <span class='hs-keyword'>| size (snd r) + 1 = size s &amp;&amp; S.union (elts (snd r)) (S.singleton (fst r)) = elts s}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>140: </span><span class='hs-definition'>deleteMin2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>141: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##2307:{s : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size s} -&gt; {r : (a, (Data.Heap.Skew.Skew {VV : a | fst r &lt;= VV})) | Data.Heap.Skew.size (snd r) + 1 == Data.Heap.Skew.size lq_tmp$x##2307
                                                                                                                                     &amp;&amp; Set_cup (Data.Heap.Skew.elts (snd r)) (Set_sng (fst r)) == Data.Heap.Skew.elts lq_tmp$x##2307}</span><span class='hs-definition'>deleteMin2</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b &lt;p2 :: a b -&gt; Bool&gt; .
lq_tmp$x##2423:a -&gt; lq_tmp$x##2424:{lq_tmp$x##2415 : b&lt;p2 lq_tmp$x##2423&gt; | true} -&gt; {lq_tmp$x##2420 : (a, b)&lt;\lq_tmp$x##2425 VV -&gt; {lq_tmp$x##2419 : b&lt;p2 lq_tmp$x##2425&gt; | true}&gt; | x_Tuple22 lq_tmp$x##2420 == lq_tmp$x##2424
                                                                                                                                                                                      &amp;&amp; x_Tuple21 lq_tmp$x##2420 == lq_tmp$x##2423
                                                                                                                                                                                      &amp;&amp; snd lq_tmp$x##2420 == lq_tmp$x##2424
                                                                                                                                                                                      &amp;&amp; fst lq_tmp$x##2420 == lq_tmp$x##2423}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##2446 : a | lq_tmp$x##2446 == x##a2u6}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2396 : (Data.Heap.Skew.Skew {lq_tmp$x##2406 : a^"lq_tmp$x##2405" | $k_##2404[VV##2403:=lq_tmp$x##2406][lq_tmp$x##2400:=fix$36$$36$dOrd_a39w][lq_tmp$x##2401:=l##a2u7][lq_tmp$x##2402:=r##a2u8]}) | Data.Heap.Skew.size lq_tmp$x##2396 == Data.Heap.Skew.size l##a2u7 + Data.Heap.Skew.size r##a2u8
                                                                                                                                                                                                              &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2396 == Set_cup (Data.Heap.Skew.elts l##a2u7) (Data.Heap.Skew.elts r##a2u8)}</span><span class='hs-varid'>merge</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2410 : (Data.Heap.Skew.Skew {lq_tmp$x##2409 : a | x##a2u6 &lt;= lq_tmp$x##2409}) | Data.Heap.Skew.size lq_tmp$x##2410 &gt;= 0
                                                                                           &amp;&amp; lq_tmp$x##2410 == l##a2u7}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2412 : (Data.Heap.Skew.Skew {lq_tmp$x##2411 : a | x##a2u6 &lt;= lq_tmp$x##2411}) | Data.Heap.Skew.size lq_tmp$x##2412 &gt;= 0
                                                                                           &amp;&amp; lq_tmp$x##2412 == r##a2u8}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum>144: </span><span class='hs-comment'>-- -- {-| Merging two heaps-}</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>elts</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>elts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>148: </span><span class='hs-definition'>elts</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>149: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##1460:(Data.Heap.Skew.Skew a) -&gt; {VV : (Data.Set.Internal.Set a) | VV == Data.Heap.Skew.elts lq_tmp$x##1460}</span><span class='hs-definition'>elts</span></a> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
{lq_tmp$x##1476 : (Data.Set.Internal.Set a) | Set_emp lq_tmp$x##1476}</span><span class='hs-conid'>S.empty</span></a>
<span class=hs-linenum>150: </span><span class='hs-definition'>elts</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>rt</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1604 : (GHC.Classes.Ord a) | lq_tmp$x##1604 == $dOrd_a39i}</span><span class='hs-conid'>S.union</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1513 : (Data.Set.Internal.Set {lq_tmp$x##1519 : a^"lq_tmp$x##1518" | $k_##1517[VV##1516:=lq_tmp$x##1519][lq_tmp$x##1515:=rt##a2u9]}) | lq_tmp$x##1513 == Set_sng rt##a2u9}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.singleton</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1520 : a | lq_tmp$x##1520 == rt##a2u9}</span><span class='hs-varid'>rt</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1567 : (Data.Set.Internal.Set {lq_tmp$x##1577 : a^"lq_tmp$x##1576" | $k_##1575[VV##1574:=lq_tmp$x##1577][lq_tmp$x##1571:=fix$36$$36$dOrd_a39i][lq_tmp$x##1572:=lq_anf$##7205759403792806378##d3k6][lq_tmp$x##1573:=lq_anf$##7205759403792806379##d3k7]}) | lq_tmp$x##1567 == Set_cup lq_anf$##7205759403792806378##d3k6 lq_anf$##7205759403792806379##d3k7}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.union</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1527 : (Data.Set.Internal.Set {lq_tmp$x##1535 : a^"lq_tmp$x##1534" | $k_##1533[VV##1532:=lq_tmp$x##1535][lq_tmp$x##1530:=fix$36$$36$dOrd_a39i][lq_tmp$x##1531:=l##a2ua]}) | lq_tmp$x##1527 == Data.Heap.Skew.elts l##a2ua}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>elts</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1539 : (Data.Heap.Skew.Skew {lq_tmp$x##1538 : a | rt##a2u9 &lt;= lq_tmp$x##1538}) | Data.Heap.Skew.size lq_tmp$x##1539 &gt;= 0
                                                                                            &amp;&amp; lq_tmp$x##1539 == l##a2ua}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1546 : (Data.Set.Internal.Set {lq_tmp$x##1554 : a^"lq_tmp$x##1553" | $k_##1552[VV##1551:=lq_tmp$x##1554][lq_tmp$x##1549:=fix$36$$36$dOrd_a39i][lq_tmp$x##1550:=r##a2ub]}) | lq_tmp$x##1546 == Data.Heap.Skew.elts r##a2ub}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>elts</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1558 : (Data.Heap.Skew.Skew {lq_tmp$x##1557 : a | rt##a2u9 &lt;= lq_tmp$x##1557}) | Data.Heap.Skew.size lq_tmp$x##1558 &gt;= 0
                                                                                            &amp;&amp; lq_tmp$x##1558 == r##a2ub}</span><span class='hs-varid'>r</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>151: </span>
<span class=hs-linenum>152: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>eltsList</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>153: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>eltsList</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>154: </span><span class='hs-definition'>eltsList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>155: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##1621:[a] -&gt; {VV : (Data.Set.Internal.Set a) | VV == Data.Heap.Skew.eltsList lq_tmp$x##1621}</span><span class='hs-definition'>eltsList</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
{lq_tmp$x##1649 : (Data.Set.Internal.Set a) | Set_emp lq_tmp$x##1649}</span><span class='hs-conid'>S.empty</span></a>
<span class=hs-linenum>156: </span><span class='hs-definition'>eltsList</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1746 : (GHC.Classes.Ord a) | lq_tmp$x##1746 == $dOrd_a395}</span><span class='hs-conid'>S.union</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1692 : (Data.Set.Internal.Set {lq_tmp$x##1698 : a^"lq_tmp$x##1697" | $k_##1696[VV##1695:=lq_tmp$x##1698][lq_tmp$x##1694:=x##a2uc]}) | lq_tmp$x##1692 == Set_sng x##a2uc}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.singleton</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1699 : a | lq_tmp$x##1699 == x##a2uc}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1708 : (Data.Set.Internal.Set {lq_tmp$x##1718 : a^"lq_tmp$x##1717" | $k_##1716[VV##1715:=lq_tmp$x##1718][lq_tmp$x##1712:=fix$36$$36$dOrd_a395][lq_tmp$x##1713:=xs##a2ud]}) | lq_tmp$x##1708 == Data.Heap.Skew.eltsList xs##a2ud}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>eltsList</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1724 : [a] | len lq_tmp$x##1724 &gt;= 0
                        &amp;&amp; lq_tmp$x##1724 == xs##a2ud}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>157: </span>
<span class=hs-linenum>158: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>EqElts</span> <span class='hs-conid'>X</span> <span class='hs-conid'>Y</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>elts</span> <span class='hs-conid'>X</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>elts</span> <span class='hs-conid'>Y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>159: </span>
<span class=hs-linenum>160: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>assert</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>161: </span><span class='hs-definition'>assert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>162: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1763:{v : GHC.Types.Bool | v} -&gt; lq_tmp$x##1764:a -&gt; a</span><span class='hs-definition'>assert</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>163: </span>
<span class=hs-linenum>164: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>skewBoundedByRoot</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{s:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>| 0 &lt; size s}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r :</span> <span class='hs-conid'>Skew</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>minimum</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>| size s = size r &amp;&amp; EqElts s r}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>165: </span><span class='hs-definition'>skewBoundedByRoot</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>166: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1775:{VV : (Data.Heap.Skew.Skew a) | 0 &lt; Data.Heap.Skew.size VV} -&gt; {r : (Data.Heap.Skew.Skew {VV : a | Data.Heap.Skew.minimum lq_tmp$x##1775 &lt;= VV}) | Data.Heap.Skew.size lq_tmp$x##1775 == Data.Heap.Skew.size r
                                                                                                                                                                  &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##1775 == Data.Heap.Skew.elts r}</span><span class='hs-definition'>skewBoundedByRoot</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>rt</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1847:a -&gt; lq_tmp$x##1848:(Data.Heap.Skew.Skew {lq_tmp$x##1838 : a | lq_tmp$x##1847 &lt;= lq_tmp$x##1838}) -&gt; lq_tmp$x##1849:(Data.Heap.Skew.Skew {lq_tmp$x##1840 : a | lq_tmp$x##1847 &lt;= lq_tmp$x##1840}) -&gt; {lq_tmp$x##1843 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.right lq_tmp$x##1843 == lq_tmp$x##1849
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.left lq_tmp$x##1843 == lq_tmp$x##1848
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.root lq_tmp$x##1843 == lq_tmp$x##1847
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##1843 == Set_cup (Set_sng lq_tmp$x##1847) (Set_cup (Data.Heap.Skew.elts lq_tmp$x##1848) (Data.Heap.Skew.elts lq_tmp$x##1849))
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##1843 == lq_tmp$x##1847
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.size lq_tmp$x##1843 == (1 + Data.Heap.Skew.size lq_tmp$x##1848) + Data.Heap.Skew.size lq_tmp$x##1849}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1854 : a | lq_tmp$x##1854 == rt##a2uf}</span><span class='hs-varid'>rt</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1856 : (Data.Heap.Skew.Skew {lq_tmp$x##1855 : a | rt##a2uf &lt;= lq_tmp$x##1855}) | Data.Heap.Skew.size lq_tmp$x##1856 &gt;= 0
                                                                                            &amp;&amp; lq_tmp$x##1856 == l##a2ug}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1858 : (Data.Heap.Skew.Skew {lq_tmp$x##1857 : a | rt##a2uf &lt;= lq_tmp$x##1857}) | Data.Heap.Skew.size lq_tmp$x##1858 &gt;= 0
                                                                                            &amp;&amp; lq_tmp$x##1858 == r##a2uh}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>boundedSkewTransitive</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{y:</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| y &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r :</span> <span class='hs-conid'>Skew</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bounded</span> <span class='hs-varid'>a</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyword'>| size s = size r &amp;&amp; EqElts s r}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>169: </span><span class='hs-definition'>boundedSkewTransitive</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1864:a -&gt; lq_tmp$x##1865:(Data.Heap.Skew.Skew {VV : a | lq_tmp$x##1864 &lt;= VV}) -&gt; lq_tmp$x##1866:{VV : a | VV &lt;= lq_tmp$x##1864} -&gt; {r : (Data.Heap.Skew.Skew {VV : a | lq_tmp$x##1866 &lt;= VV}) | Data.Heap.Skew.size lq_tmp$x##1865 == Data.Heap.Skew.size r
                                                                                                                                                                                                           &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##1865 == Data.Heap.Skew.elts r}</span><span class='hs-definition'>boundedSkewTransitive</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>(Data.Heap.Skew.Skew {VV : a | ds_d3gX &lt;= VV})</span><span class='hs-varid'>s</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>171: </span>
<span class=hs-linenum>172: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>merge</span> <span class='hs-keyglyph'>::</span><span class='hs-varid'>t1</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t2</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{r:</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| size r = size t1 + size t2 &amp;&amp; ((elts r) = (S.union (elts t1) (elts t2)))}</span>  <span class='hs-varop'>/</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>size</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>size</span> <span class='hs-varid'>t2</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>173: </span><span class='hs-definition'>merge</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>174: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##1894:(Data.Heap.Skew.Skew a) -&gt; lq_tmp$x##1895:(Data.Heap.Skew.Skew a) -&gt; {r : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size r == Data.Heap.Skew.size lq_tmp$x##1894 + Data.Heap.Skew.size lq_tmp$x##1895
                                                                                                                   &amp;&amp; Data.Heap.Skew.elts r == Set_cup (Data.Heap.Skew.elts lq_tmp$x##1894) (Data.Heap.Skew.elts lq_tmp$x##1895)}</span><span class='hs-definition'>merge</span></a> <a class=annot href="#"><span class=annottext>(Data.Heap.Skew.Skew a)</span><span class='hs-varid'>t1</span></a> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1912 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size lq_tmp$x##1912 &gt;= 0
                                            &amp;&amp; lq_tmp$x##1912 == t1##a2uj}</span><span class='hs-varid'>t1</span></a>
<span class=hs-linenum>175: </span><span class='hs-definition'>merge</span> <span class='hs-conid'>Leaf</span> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1955 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size lq_tmp$x##1955 &gt;= 0
                                            &amp;&amp; lq_tmp$x##1955 == ds_d3hb}</span><span class='hs-varid'>t2</span></a>
<span class=hs-linenum>176: </span><span class='hs-definition'>merge</span> <span class='hs-varid'>t1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>rt1</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>r1</span><span class='hs-layout'>)</span> <span class='hs-varid'>t2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-varid'>rt2</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>r2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>177: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2063 : a | lq_tmp$x##2063 == rt1##a2um}</span><span class='hs-varid'>rt1</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2064 : a | lq_tmp$x##2064 == rt2##a2uq}</span><span class='hs-varid'>rt2</span></a> <span class='hs-keyword'>then</span>
<span class=hs-linenum>178: </span>        <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2274:a -&gt; lq_tmp$x##2275:(Data.Heap.Skew.Skew {lq_tmp$x##2265 : a | lq_tmp$x##2274 &lt;= lq_tmp$x##2265}) -&gt; lq_tmp$x##2276:(Data.Heap.Skew.Skew {lq_tmp$x##2267 : a | lq_tmp$x##2274 &lt;= lq_tmp$x##2267}) -&gt; {lq_tmp$x##2270 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.right lq_tmp$x##2270 == lq_tmp$x##2276
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2270 == lq_tmp$x##2275
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2270 == lq_tmp$x##2274
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2270 == Set_cup (Set_sng lq_tmp$x##2274) (Set_cup (Data.Heap.Skew.elts lq_tmp$x##2275) (Data.Heap.Skew.elts lq_tmp$x##2276))
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2270 == lq_tmp$x##2274
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2270 == (1 + Data.Heap.Skew.size lq_tmp$x##2275) + Data.Heap.Skew.size lq_tmp$x##2276}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2281 : a | lq_tmp$x##2281 == rt1##a2um}</span><span class='hs-varid'>rt1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2283 : (Data.Heap.Skew.Skew {lq_tmp$x##2282 : a | rt1##a2um &lt;= lq_tmp$x##2282}) | Data.Heap.Skew.size lq_tmp$x##2283 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2283 == r1##a2uo}</span><span class='hs-varid'>r1</span></a> <a class=annot href="#"><span class=annottext>{r : (Data.Heap.Skew.Skew {lq_tmp$x##2256 : a^"lq_tmp$x##2255" | $k_##2254[VV##2253:=lq_tmp$x##2256][lq_tmp$x##1893:=fix$36$$36$dOrd_a38L][lq_tmp$x##1894:=l1##a2un][lq_tmp$x##1895:=lq_anf$##7205759403792806398##d3kq]}) | Data.Heap.Skew.size r == Data.Heap.Skew.size l1##a2un + Data.Heap.Skew.size lq_anf$##7205759403792806398##d3kq
                                                                                                                                                                                                                             &amp;&amp; Data.Heap.Skew.elts r == Set_cup (Data.Heap.Skew.elts l1##a2un) (Data.Heap.Skew.elts lq_anf$##7205759403792806398##d3kq)}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>merge</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2260 : (Data.Heap.Skew.Skew {lq_tmp$x##2259 : a | rt1##a2um &lt;= lq_tmp$x##2259}) | Data.Heap.Skew.size lq_tmp$x##2260 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2260 == l1##a2un}</span><span class='hs-varid'>l1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2223 : (Data.Heap.Skew.Skew {lq_tmp$x##2233 : a^"lq_tmp$x##2232" | $k_##2231[VV##2230:=lq_tmp$x##2233][lq_tmp$x##2227:=rt2##a2uq][lq_tmp$x##2228:=lq_anf$##7205759403792806397##d3kp][lq_tmp$x##2229:=rt1##a2um]
                                                                              &amp;&amp; rt1##a2um &lt;= lq_tmp$x##2233}) | Data.Heap.Skew.size lq_anf$##7205759403792806397##d3kp == Data.Heap.Skew.size lq_tmp$x##2223
                                                                                                                 &amp;&amp; Data.Heap.Skew.elts lq_anf$##7205759403792806397##d3kp == Data.Heap.Skew.elts lq_tmp$x##2223}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>boundedSkewTransitive</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2234 : a | lq_tmp$x##2234 == rt2##a2uq}</span><span class='hs-varid'>rt2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2208 : (Data.Heap.Skew.Skew {lq_tmp$x##2214 : a^"lq_tmp$x##2213" | $k_##2212[VV##2211:=lq_tmp$x##2214][lq_tmp$x##2210:=lq_anf$##7205759403792806396##d3ko]
                                                                              &amp;&amp; Data.Heap.Skew.minimum lq_anf$##7205759403792806396##d3ko &lt;= lq_tmp$x##2214}) | Data.Heap.Skew.size lq_anf$##7205759403792806396##d3ko == Data.Heap.Skew.size lq_tmp$x##2208
                                                                                                                                                                 &amp;&amp; Data.Heap.Skew.elts lq_anf$##7205759403792806396##d3ko == Data.Heap.Skew.elts lq_tmp$x##2208}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>skewBoundedByRoot</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2188 : (Data.Heap.Skew.Skew {lq_tmp$x##2198 : a^"lq_tmp$x##2197" | $k_##2196[VV##2195:=lq_tmp$x##2198][lq_tmp$x##2192:=rt2##a2uq][lq_tmp$x##2193:=l2##a2ur][lq_tmp$x##2194:=r2##a2us]}) | Data.Heap.Skew.right lq_tmp$x##2188 == r2##a2us
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2188 == l2##a2ur
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2188 == rt2##a2uq
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2188 == Set_cup (Set_sng rt2##a2uq) (Set_cup (Data.Heap.Skew.elts l2##a2ur) (Data.Heap.Skew.elts r2##a2us))
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2188 == rt2##a2uq
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2188 == (1 + Data.Heap.Skew.size l2##a2ur) + Data.Heap.Skew.size r2##a2us}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Node</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2199 : a | lq_tmp$x##2199 == rt2##a2uq}</span><span class='hs-varid'>rt2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2201 : (Data.Heap.Skew.Skew {lq_tmp$x##2200 : a | rt2##a2uq &lt;= lq_tmp$x##2200}) | Data.Heap.Skew.size lq_tmp$x##2201 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2201 == l2##a2ur}</span><span class='hs-varid'>l2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2203 : (Data.Heap.Skew.Skew {lq_tmp$x##2202 : a | rt2##a2uq &lt;= lq_tmp$x##2202}) | Data.Heap.Skew.size lq_tmp$x##2203 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2203 == r2##a2us}</span><span class='hs-varid'>r2</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2237 : a | lq_tmp$x##2237 == rt1##a2um}</span><span class='hs-varid'>rt1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>179: </span>    <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2165:a -&gt; lq_tmp$x##2166:(Data.Heap.Skew.Skew {lq_tmp$x##2156 : a | lq_tmp$x##2165 &lt;= lq_tmp$x##2156}) -&gt; lq_tmp$x##2167:(Data.Heap.Skew.Skew {lq_tmp$x##2158 : a | lq_tmp$x##2165 &lt;= lq_tmp$x##2158}) -&gt; {lq_tmp$x##2161 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.right lq_tmp$x##2161 == lq_tmp$x##2167
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2161 == lq_tmp$x##2166
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2161 == lq_tmp$x##2165
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2161 == Set_cup (Set_sng lq_tmp$x##2165) (Set_cup (Data.Heap.Skew.elts lq_tmp$x##2166) (Data.Heap.Skew.elts lq_tmp$x##2167))
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2161 == lq_tmp$x##2165
                                                                                                                                                                                                                                                                &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2161 == (1 + Data.Heap.Skew.size lq_tmp$x##2166) + Data.Heap.Skew.size lq_tmp$x##2167}</span><span class='hs-conid'>Node</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2172 : a | lq_tmp$x##2172 == rt2##a2uq}</span><span class='hs-varid'>rt2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2174 : (Data.Heap.Skew.Skew {lq_tmp$x##2173 : a | rt2##a2uq &lt;= lq_tmp$x##2173}) | Data.Heap.Skew.size lq_tmp$x##2174 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2174 == r2##a2us}</span><span class='hs-varid'>r2</span></a> <a class=annot href="#"><span class=annottext>{r : (Data.Heap.Skew.Skew {lq_tmp$x##2147 : a^"lq_tmp$x##2146" | $k_##2145[VV##2144:=lq_tmp$x##2147][lq_tmp$x##1893:=fix$36$$36$dOrd_a38L][lq_tmp$x##1894:=l2##a2ur][lq_tmp$x##1895:=lq_anf$##7205759403792806394##d3km]}) | Data.Heap.Skew.size r == Data.Heap.Skew.size l2##a2ur + Data.Heap.Skew.size lq_anf$##7205759403792806394##d3km
                                                                                                                                                                                                                             &amp;&amp; Data.Heap.Skew.elts r == Set_cup (Data.Heap.Skew.elts l2##a2ur) (Data.Heap.Skew.elts lq_anf$##7205759403792806394##d3km)}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>merge</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2151 : (Data.Heap.Skew.Skew {lq_tmp$x##2150 : a | rt2##a2uq &lt;= lq_tmp$x##2150}) | Data.Heap.Skew.size lq_tmp$x##2151 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2151 == l2##a2ur}</span><span class='hs-varid'>l2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2114 : (Data.Heap.Skew.Skew {lq_tmp$x##2124 : a^"lq_tmp$x##2123" | $k_##2122[VV##2121:=lq_tmp$x##2124][lq_tmp$x##2118:=rt1##a2um][lq_tmp$x##2119:=lq_anf$##7205759403792806393##d3kl][lq_tmp$x##2120:=rt2##a2uq]
                                                                              &amp;&amp; rt2##a2uq &lt;= lq_tmp$x##2124}) | Data.Heap.Skew.size lq_anf$##7205759403792806393##d3kl == Data.Heap.Skew.size lq_tmp$x##2114
                                                                                                                 &amp;&amp; Data.Heap.Skew.elts lq_anf$##7205759403792806393##d3kl == Data.Heap.Skew.elts lq_tmp$x##2114}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>boundedSkewTransitive</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2125 : a | lq_tmp$x##2125 == rt1##a2um}</span><span class='hs-varid'>rt1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2099 : (Data.Heap.Skew.Skew {lq_tmp$x##2105 : a^"lq_tmp$x##2104" | $k_##2103[VV##2102:=lq_tmp$x##2105][lq_tmp$x##2101:=lq_anf$##7205759403792806392##d3kk]
                                                                              &amp;&amp; Data.Heap.Skew.minimum lq_anf$##7205759403792806392##d3kk &lt;= lq_tmp$x##2105}) | Data.Heap.Skew.size lq_anf$##7205759403792806392##d3kk == Data.Heap.Skew.size lq_tmp$x##2099
                                                                                                                                                                 &amp;&amp; Data.Heap.Skew.elts lq_anf$##7205759403792806392##d3kk == Data.Heap.Skew.elts lq_tmp$x##2099}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>skewBoundedByRoot</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2079 : (Data.Heap.Skew.Skew {lq_tmp$x##2089 : a^"lq_tmp$x##2088" | $k_##2087[VV##2086:=lq_tmp$x##2089][lq_tmp$x##2083:=rt1##a2um][lq_tmp$x##2084:=l1##a2un][lq_tmp$x##2085:=r1##a2uo]}) | Data.Heap.Skew.right lq_tmp$x##2079 == r1##a2uo
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.left lq_tmp$x##2079 == l1##a2un
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.root lq_tmp$x##2079 == rt1##a2um
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.elts lq_tmp$x##2079 == Set_cup (Set_sng rt1##a2um) (Set_cup (Data.Heap.Skew.elts l1##a2un) (Data.Heap.Skew.elts r1##a2uo))
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.minimum lq_tmp$x##2079 == rt1##a2um
                                                                                                                                                                                                     &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2079 == (1 + Data.Heap.Skew.size l1##a2un) + Data.Heap.Skew.size r1##a2uo}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Node</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2090 : a | lq_tmp$x##2090 == rt1##a2um}</span><span class='hs-varid'>rt1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2092 : (Data.Heap.Skew.Skew {lq_tmp$x##2091 : a | rt1##a2um &lt;= lq_tmp$x##2091}) | Data.Heap.Skew.size lq_tmp$x##2092 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2092 == l1##a2un}</span><span class='hs-varid'>l1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2094 : (Data.Heap.Skew.Skew {lq_tmp$x##2093 : a | rt1##a2um &lt;= lq_tmp$x##2093}) | Data.Heap.Skew.size lq_tmp$x##2094 &gt;= 0
                                                                                             &amp;&amp; lq_tmp$x##2094 == r1##a2uo}</span><span class='hs-varid'>r1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2128 : a | lq_tmp$x##2128 == rt2##a2uq}</span><span class='hs-varid'>rt2</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>180: </span>
<span class=hs-linenum>181: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum>182: </span><span class='hs-comment'>-- -- -- Basic operations</span>
<span class=hs-linenum>183: </span><span class='hs-comment'>-- -- ----------------------------------------------------------------</span>
<span class=hs-linenum>184: </span>
<span class=hs-linenum>185: </span><span class='hs-comment'>-- -- {-| Checking validity of a heap.</span>
<span class=hs-linenum>186: </span><span class='hs-comment'>-- -- -}</span>
<span class=hs-linenum>187: </span>
<span class=hs-linenum>188: </span><span class='hs-comment'>-- -- valid :: Ord a =&gt; Skew a -&gt; Bool</span>
<span class=hs-linenum>189: </span><span class='hs-comment'>-- -- valid t = isOrdered (heapSort t)</span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>IncrList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-varop'>&lt;</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>xi</span> <span class='hs-varid'>xj</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>xj</span><span class='hs-layout'>}</span><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span>
<span class=hs-linenum>193: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>heapSort</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span> <span class='hs-conid'>IncrList</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>| len v = size s &amp;&amp; eltsList v = elts s}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>size</span> <span class='hs-varid'>s</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>194: </span><span class='hs-definition'>heapSort</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Skew</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>195: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##2472:(Data.Heap.Skew.Skew a) -&gt; {VV##0 : [a]&lt;\lq_tmp$x##2473 VV -&gt; {VV : a | lq_tmp$x##2473 &lt;= VV}&gt; | len VV##0 == Data.Heap.Skew.size lq_tmp$x##2472
                                                                                                                &amp;&amp; Data.Heap.Skew.eltsList VV##0 == Data.Heap.Skew.elts lq_tmp$x##2472}</span><span class='hs-definition'>heapSort</span></a> <span class='hs-conid'>Leaf</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a &lt;p :: a a -&gt; Bool&gt; .
{lq_tmp$x##2491 : [a]&lt;\lq_tmp$x##2492 VV -&gt; {lq_tmp$x##2490 : a&lt;p lq_tmp$x##2492&gt; | true}&gt; | Data.Heap.Skew.eltsList lq_tmp$x##2491 == Set_empty 0
                                                                                             &amp;&amp; Set_emp (listElts lq_tmp$x##2491)
                                                                                             &amp;&amp; len lq_tmp$x##2491 == 0}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>196: </span><span class='hs-definition'>heapSort</span> <span class='hs-varid'>h</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>197: </span>    <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV##2557 : a^"lq_tmp$x##2559" | $k_##2558}</span><span class='hs-varid'>minElt</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV##2599 : (Data.Heap.Skew.Skew {VV##2596 : a^"lq_tmp$x##2598" | $k_##2597})^"lq_tmp$x##2601" | $k_##2600}</span><span class='hs-varid'>h'</span></a><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2542 : ({lq_tmp$x##2551 : a^"lq_tmp$x##2550" | $k_##2549[VV##2548:=lq_tmp$x##2551][lq_tmp$x##2545:=fix$36$$36$dOrd_a39C][lq_tmp$x##2546:=ds_d3hW]}, (Data.Heap.Skew.Skew {lq_tmp$x##2551 : a^"lq_tmp$x##2550" | $k_##2549[VV##2548:=lq_tmp$x##2551][lq_tmp$x##2545:=fix$36$$36$dOrd_a39C][lq_tmp$x##2546:=ds_d3hW]
                                                                                                                                                                                                                           &amp;&amp; fst lq_tmp$x##2542 &lt;= lq_tmp$x##2551})) | Data.Heap.Skew.size (snd lq_tmp$x##2542) + 1 == Data.Heap.Skew.size ds_d3hW
                                                                                                                                                                                                                                                                        &amp;&amp; Set_cup (Data.Heap.Skew.elts (snd lq_tmp$x##2542)) (Set_sng (fst lq_tmp$x##2542)) == Data.Heap.Skew.elts ds_d3hW}</span><span class='hs-varid'>deleteMin2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2555 : (Data.Heap.Skew.Skew a) | Data.Heap.Skew.size lq_tmp$x##2555 &gt;= 0
                                            &amp;&amp; lq_tmp$x##2555 == ds_d3hW}</span><span class='hs-varid'>h</span></a> <span class='hs-keyword'>in</span>
<span class=hs-linenum>198: </span>        <a class=annot href="#"><span class=annottext>{lq_tmp$x##2685 : a^"lq_tmp$x##2559" | $k_##2558[VV##2557:=lq_tmp$x##2685]
                                       &amp;&amp; lq_tmp$x##2685 == minElt##a39J}</span><span class='hs-varid'>minElt</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{VV##0 : [{lq_tmp$x##2654 : a^"lq_tmp$x##2653" | $k_##2652[VV##2651:=lq_tmp$x##2654][lq_tmp$x##2471:=fix$36$$36$dOrd_a39C][lq_tmp$x##2472:=h'##a39L]}]&lt;\lq_tmp$x##2473 VV -&gt; {lq_tmp$x##2654 : a^"lq_tmp$x##2653" | lq_tmp$x##2473 &lt;= lq_tmp$x##2654}&gt; | len VV##0 == Data.Heap.Skew.size h'##a39L
                                                                                                                                                                                                                                                         &amp;&amp; Data.Heap.Skew.eltsList VV##0 == Data.Heap.Skew.elts h'##a39L}</span><span class='hs-varid'>heapSort</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2658 : (Data.Heap.Skew.Skew {lq_tmp$x##2657 : a^"lq_tmp$x##2598" | $k_##2597[VV##2596:=lq_tmp$x##2657][VV##2599:=lq_tmp$x##2658]})^"lq_tmp$x##2601" | $k_##2600[VV##2599:=lq_tmp$x##2658]
                                                                                                                                                                 &amp;&amp; Data.Heap.Skew.size lq_tmp$x##2658 &gt;= 0
                                                                                                                                                                 &amp;&amp; lq_tmp$x##2658 == h'##a39L}</span><span class='hs-varid'>h'</span></a>
<span class=hs-linenum>199: </span>
<span class=hs-linenum>200: </span><span class='hs-comment'>-- -- isOrdered :: Ord a =&gt; [a] -&gt; Bool</span>
<span class=hs-linenum>201: </span><span class='hs-comment'>-- -- isOrdered [] = True</span>
<span class=hs-linenum>202: </span><span class='hs-comment'>-- -- isOrdered [_] = True</span>
<span class=hs-linenum>203: </span><span class='hs-comment'>-- -- isOrdered (x:y:xys) = x &lt;= y &amp;&amp; isOrdered (y:xys) -- allowing duplicated keys</span></pre>
</body>
</html>