1:1-1:1::Data.Heap.Skew.$trModule :: "GHC.Types.Module"
49:1-49:5::Data.Heap.Skew.size :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {VV : GHC.Types.Int | VV == size x1\n                                                    && VV >= 0}"
49:13-49:14::lq_anf$##7205759403792806365 :: "{v : GHC.Prim.Int# | v == 0}"
50:21-50:22::lq_anf$##7205759403792806367 :: "GHC.Types.Int"
50:25-50:31::lq_anf$##7205759403792806368 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
50:30-50:31::l :: "{v : (Data.Heap.Skew.Skew a) | v == l}"
50:34-50:40::lq_anf$##7205759403792806370 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
50:39-50:40::r :: "{v : (Data.Heap.Skew.Skew a) | v == r}"
56:1-56:6::Data.Heap.Skew.empty :: "forall a .\n{r : (Data.Heap.Skew.Skew a) | size r == 0\n                               && elts r == Set_empty 0}"
62:1-62:5::Data.Heap.Skew.null :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {b : GHC.Types.Bool | b <=> size x1 == 0}"
62:21-62:25::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
63:21-63:26::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
69:1-69:10::Data.Heap.Skew.singleton :: "forall a .\nx1:a -> {r : (Data.Heap.Skew.Skew a) | size r == 1\n                                       && elts r == Set_sng x1}"
69:11-69:12::x :: "a"
69:20-69:21::x :: "{VV : a | VV == x}"
69:22-69:26::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
69:27-69:31::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
77:1-77:7::Data.Heap.Skew.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:a -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == 1 + size x3\n                                                                     && elts r == Set_cup (elts x3) (Set_sng x2)}"
77:8-77:9::x :: "a"
77:10-77:11::t :: "(Data.Heap.Skew.Skew a)"
77:20-77:33::lq_anf$##7205759403792806411 :: "{v : (Data.Heap.Skew.Skew a) | size v == 1\n                               && elts v == Set_sng x}"
77:31-77:32::x :: "{VV : a | VV == x}"
77:34-77:35::t :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t}"
84:1-84:9::Data.Heap.Skew.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {r : (Data.Heap.Skew.Skew a) | size r == len x2\n                                         && elts r == listElts x2}"
84:15-84:19::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
85:21-85:43::$dOrd_a3cn :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a3cn}"
85:28-85:29::x :: "{VV : a | VV == x}"
85:30-85:43::lq_anf$##7205759403792806413 :: "{v : (Data.Heap.Skew.Skew a) | size v == len xs\n                               && elts v == listElts xs}"
85:40-85:42::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
128:1-128:8::Data.Heap.Skew.minimum :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {VV : a | VV == minimum x1}"
128:24-128:25::x :: "{VV : a | VV == x}"
136:1-136:10::Data.Heap.Skew.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (Data.Heap.Skew.Skew a) | size r + 1 == size x2}"
136:11-136:12::t :: "{s : (Data.Heap.Skew.Skew a) | 0 < size s}"
136:28-136:46::Data.Tuple.snd :: "forall a b . x1:(a, b) -> {VV : b | VV == snd x1}"
136:32-136:46::lq_anf$##7205759403792806410 :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
136:44-136:45::lq_anf$##7205759403792806408 :: "{v : (Data.Heap.Skew.Skew a) | 0 < size v\n                               && size v >= 0\n                               && v == t}"
141:1-141:11::Data.Heap.Skew.deleteMin2 :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (a, (Data.Heap.Skew.Skew {VV : a | fst r <= VV})) | size (snd r) + 1 == size x2\n                                                                                                          && Set_cup (elts (snd r)) (Set_sng (fst r)) == elts x2}"
141:30-141:44::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Bool> .\nx1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                     && x_Tuple21 v == x1\n                                                                                     && snd v == x2\n                                                                                     && fst v == x1}"
141:31-141:32::x :: "{VV : a | VV == x}"
141:34-141:43::lq_anf$##7205759403792806405 :: "{v : (Data.Heap.Skew.Skew a) | size v == size l + size r\n                               && elts v == Set_cup (elts l) (elts r)}"
141:40-141:41::l :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == l}"
141:42-141:43::r :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == r}"
149:1-149:5::Data.Heap.Skew.elts :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : (Data.Set.Internal.Set a) | VV == elts x2}"
149:13-149:20::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
150:22-150:74::$dOrd_a39i :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a39i}"
150:30-150:46::lq_anf$##7205759403792806377 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng rt}"
150:43-150:45::rt :: "{VV : a | VV == rt}"
150:47-150:74::lq_anf$##7205759403792806380 :: "(Data.Set.Internal.Set a)"
150:56-150:64::lq_anf$##7205759403792806378 :: "{v : (Data.Set.Internal.Set a) | v == elts l}"
150:62-150:63::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
150:65-150:73::lq_anf$##7205759403792806379 :: "{v : (Data.Set.Internal.Set a) | v == elts r}"
150:71-150:72::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
155:1-155:9::Data.Heap.Skew.eltsList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {VV : (Data.Set.Internal.Set a) | VV == eltsList x2}"
155:15-155:22::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
156:21-156:58::$dOrd_a395 :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a395}"
156:29-156:44::lq_anf$##7205759403792806382 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng x}"
156:42-156:43::x :: "{VV : a | VV == x}"
156:45-156:58::lq_anf$##7205759403792806383 :: "{v : (Data.Set.Internal.Set a) | v == eltsList xs}"
156:55-156:57::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
162:1-162:7::Data.Heap.Skew.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
162:10-162:11::x :: "a"
166:1-166:18::Data.Heap.Skew.skewBoundedByRoot :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {r : (Data.Heap.Skew.Skew {VV : a | minimum x1 <= VV}) | size x1 == size r\n                                                                                                            && elts x1 == elts r}"
166:35-166:46::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
166:40-166:42::rt :: "{VV : a | VV == rt}"
166:43-166:44::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
166:45-166:46::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
170:1-170:22::Data.Heap.Skew.boundedSkewTransitive :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:{VV : a | VV <= x1} -> {r : (Data.Heap.Skew.Skew {VV : a | x3 <= VV}) | size x2 == size r\n                                                                                                                                   && elts x2 == elts r}"
170:25-170:26::s :: "(Data.Heap.Skew.Skew a)"
174:1-174:6::Data.Heap.Skew.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == size x2 + size x3\n                                                                                           && elts r == Set_cup (elts x2) (elts x3)}"
174:7-174:9::t1 :: "(Data.Heap.Skew.Skew a)"
174:17-174:19::t1 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t1}"
175:17-175:19::ds_d3hb :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
177:8-177:11::rt1 :: "{VV : a | VV == rt1}"
177:15-177:18::rt2 :: "{VV : a | VV == rt2}"
178:9-178:100::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
178:14-178:17::rt1 :: "{VV : a | VV == rt1}"
178:18-178:20::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
178:21-178:100::lq_anf$##7205759403792806399 :: "(Data.Heap.Skew.Skew a)"
178:28-178:30::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
178:31-178:99::lq_anf$##7205759403792806398 :: "(Data.Heap.Skew.Skew {VV : a | rt1 <= VV})"
178:54-178:57::rt2 :: "{VV : a | VV == rt2}"
178:58-178:94::lq_anf$##7205759403792806397 :: "(Data.Heap.Skew.Skew a)"
178:77-178:93::lq_anf$##7205759403792806396 :: "{v : (Data.Heap.Skew.Skew a) | right v == r2\n                               && left v == l2\n                               && root v == rt2\n                               && elts v == Set_cup (Set_sng rt2) (Set_cup (elts l2) (elts r2))\n                               && minimum v == rt2\n                               && size v == (1 + size l2) + size r2}"
178:83-178:86::rt2 :: "{VV : a | VV == rt2}"
178:87-178:89::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
178:90-178:92::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
178:95-178:98::rt1 :: "{VV : a | VV == rt1}"
179:10-179:101::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
179:15-179:18::rt2 :: "{VV : a | VV == rt2}"
179:19-179:21::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
179:22-179:101::lq_anf$##7205759403792806395 :: "(Data.Heap.Skew.Skew a)"
179:29-179:31::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
179:32-179:100::lq_anf$##7205759403792806394 :: "(Data.Heap.Skew.Skew {VV : a | rt2 <= VV})"
179:55-179:58::rt1 :: "{VV : a | VV == rt1}"
179:59-179:95::lq_anf$##7205759403792806393 :: "(Data.Heap.Skew.Skew a)"
179:78-179:94::lq_anf$##7205759403792806392 :: "{v : (Data.Heap.Skew.Skew a) | right v == r1\n                               && left v == l1\n                               && root v == rt1\n                               && elts v == Set_cup (Set_sng rt1) (Set_cup (elts l1) (elts r1))\n                               && minimum v == rt1\n                               && size v == (1 + size l1) + size r1}"
179:84-179:87::rt1 :: "{VV : a | VV == rt1}"
179:88-179:90::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
179:91-179:93::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
179:96-179:99::rt2 :: "{VV : a | VV == rt2}"
195:1-195:9::Data.Heap.Skew.heapSort :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size x2\n                                                                         && eltsList VV == elts x2}"
195:17-195:19::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | eltsList v == Set_empty 0\n                                            && Set_emp (listElts v)\n                                            && len v == 0}"
197:10-197:16::minElt :: "a"
197:18-197:20::h' :: "(Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                               && VV >= minElt})"
197:24-197:36::_ :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
197:35-197:36::ds_d3hW :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
198:9-198:15::minElt :: "{VV : a | VV == minElt}"
198:18-198:29::lq_anf$##7205759403792806407 :: "{VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size h'\n                                           && eltsList VV == elts h'}"
198:27-198:29::h' :: "{v : (Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                                    && VV >= minElt}) | size v >= 0\n                                                        && v == h'}"