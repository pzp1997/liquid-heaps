1:1-1:1::Data.Heap.Skew.$trModule :: "GHC.Types.Module"
51:1-51:6::Data.Heap.Skew.empty :: "forall a . {r : (Data.Heap.Skew.Skew a) | size r == 0}"
71:1-71:10::Data.Heap.Skew.singleton :: "forall a . a -> {r : (Data.Heap.Skew.Skew a) | size r == 1}"
71:11-71:12::x :: "a"
71:20-71:21::x :: "{VV : a | VV == x}"
71:22-71:26::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
71:27-71:31::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
85:1-85:7::Data.Heap.Skew.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\na -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == 1 + size x3}"
85:8-85:9::x :: "a"
85:10-85:11::t :: "(Data.Heap.Skew.Skew a)"
85:20-85:33::lq_anf$##7205759403792805107 :: "{v : (Data.Heap.Skew.Skew a) | size v == 1}"
85:31-85:32::x :: "{VV : a | VV == x}"
85:34-85:35::t :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t}"
100:1-100:9::Data.Heap.Skew.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {r : (Data.Heap.Skew.Skew a) | size r == len x2}"
100:15-100:19::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
101:21-101:43::$dOrd_a2TV :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a2TV}"
101:28-101:29::x :: "{VV : a | VV == x}"
101:30-101:43::lq_anf$##7205759403792805109 :: "{v : (Data.Heap.Skew.Skew a) | size v == len xs}"
101:40-101:42::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
135:1-135:5::Data.Heap.Skew.size :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {VV : GHC.Types.Int | VV == size x1\n                                                    && VV >= 0}"
135:13-135:14::lq_anf$##7205759403792805073 :: "{v : GHC.Prim.Int# | v == 0}"
136:21-136:22::lq_anf$##7205759403792805075 :: "GHC.Types.Int"
136:25-136:31::lq_anf$##7205759403792805076 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
136:30-136:31::l :: "{v : (Data.Heap.Skew.Skew a) | v == l}"
136:34-136:40::lq_anf$##7205759403792805078 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
136:39-136:40::r :: "{v : (Data.Heap.Skew.Skew a) | v == r}"
141:1-141:8::Data.Heap.Skew.minimum :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {VV : a | VV == minimum x1}"
141:24-141:25::x :: "{VV : a | VV == x}"
155:1-155:10::Data.Heap.Skew.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (Data.Heap.Skew.Skew a) | size r + 1 == size x2}"
155:26-155:35::$dOrd_a2Tg :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a2Tg}"
155:32-155:33::l :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == l}"
155:34-155:35::r :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == r}"
171:1-171:5::Data.Heap.Skew.elts :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : (Data.Set.Internal.Set a) | VV == elts x2}"
171:13-171:20::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
172:22-172:74::$dOrd_a2SZ :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a2SZ}"
172:30-172:65::lq_anf$##7205759403792805084 :: "(Data.Set.Internal.Set a)"
172:39-172:55::lq_anf$##7205759403792805082 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng rt}"
172:52-172:54::rt :: "{VV : a | VV == rt}"
172:56-172:64::lq_anf$##7205759403792805083 :: "{v : (Data.Set.Internal.Set a) | v == elts l}"
172:62-172:63::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
172:66-172:74::lq_anf$##7205759403792805085 :: "{v : (Data.Set.Internal.Set a) | v == elts r}"
172:72-172:73::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
179:1-179:7::Data.Heap.Skew.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
179:10-179:11::x :: "a"
183:1-183:18::Data.Heap.Skew.skewBoundedByRoot :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {r : (Data.Heap.Skew.Skew {VV : a | minimum x1 <= VV}) | size x1 == size r}"
183:35-183:46::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
183:40-183:42::rt :: "{VV : a | VV == rt}"
183:43-183:44::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
183:45-183:46::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
187:1-187:22::Data.Heap.Skew.boundedSkewTransitive :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:{VV : a | VV <= x1} -> {r : (Data.Heap.Skew.Skew {VV : a | x3 <= VV}) | size x2 == size r}"
187:25-187:26::s :: "(Data.Heap.Skew.Skew a)"
191:1-191:6::Data.Heap.Skew.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == size x2 + size x3}"
191:7-191:9::t1 :: "(Data.Heap.Skew.Skew a)"
191:17-191:19::t1 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t1}"
192:17-192:19::ds_d2Xj :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
194:8-194:11::rt1 :: "{VV : a | VV == rt1}"
194:15-194:18::rt2 :: "{VV : a | VV == rt2}"
195:9-195:100::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
195:14-195:17::rt1 :: "{VV : a | VV == rt1}"
195:18-195:20::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
195:21-195:100::lq_anf$##7205759403792805101 :: "(Data.Heap.Skew.Skew a)"
195:28-195:30::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
195:31-195:99::lq_anf$##7205759403792805100 :: "(Data.Heap.Skew.Skew {VV : a | rt1 <= VV})"
195:54-195:57::rt2 :: "{VV : a | VV == rt2}"
195:58-195:94::lq_anf$##7205759403792805099 :: "(Data.Heap.Skew.Skew a)"
195:77-195:93::lq_anf$##7205759403792805098 :: "{v : (Data.Heap.Skew.Skew a) | right v == r2\n                               && left v == l2\n                               && root v == rt2\n                               && elts v == Set_cup (Set_cup (Set_sng rt2) (elts l2)) (elts r2)\n                               && minimum v == rt2\n                               && size v == (1 + size l2) + size r2}"
195:83-195:86::rt2 :: "{VV : a | VV == rt2}"
195:87-195:89::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
195:90-195:92::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
195:95-195:98::rt1 :: "{VV : a | VV == rt1}"
196:10-196:101::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
196:15-196:18::rt2 :: "{VV : a | VV == rt2}"
196:19-196:21::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
196:22-196:101::lq_anf$##7205759403792805097 :: "(Data.Heap.Skew.Skew a)"
196:29-196:31::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
196:32-196:100::lq_anf$##7205759403792805096 :: "(Data.Heap.Skew.Skew {VV : a | rt2 <= VV})"
196:55-196:58::rt1 :: "{VV : a | VV == rt1}"
196:59-196:95::lq_anf$##7205759403792805095 :: "(Data.Heap.Skew.Skew a)"
196:78-196:94::lq_anf$##7205759403792805094 :: "{v : (Data.Heap.Skew.Skew a) | right v == r1\n                               && left v == l1\n                               && root v == rt1\n                               && elts v == Set_cup (Set_cup (Set_sng rt1) (elts l1)) (elts r1)\n                               && minimum v == rt1\n                               && size v == (1 + size l1) + size r1}"
196:84-196:87::rt1 :: "{VV : a | VV == rt1}"
196:88-196:90::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
196:91-196:93::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
196:96-196:99::rt2 :: "{VV : a | VV == rt2}"