1:1-1:1::Data.Heap.Skew.$trModule :: "GHC.Types.Module"
51:1-51:6::Data.Heap.Skew.empty :: "forall a . (Data.Heap.Skew.Skew a)"
71:1-71:10::Data.Heap.Skew.singleton :: "forall a . a -> (Data.Heap.Skew.Skew a)"
71:11-71:12::x :: "a"
71:20-71:21::x :: "{VV : a | VV == x}"
71:22-71:26::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
71:27-71:31::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
133:1-133:5::Data.Heap.Skew.size :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {VV : GHC.Types.Int | VV == size x1\n                                                    && VV >= 0}"
133:13-133:14::lq_anf$##7205759403792804932 :: "{v : GHC.Prim.Int# | v == 0}"
134:21-134:22::lq_anf$##7205759403792804934 :: "GHC.Types.Int"
134:25-134:31::lq_anf$##7205759403792804935 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
134:30-134:31::l :: "{v : (Data.Heap.Skew.Skew a) | v == l}"
134:34-134:40::lq_anf$##7205759403792804937 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
134:39-134:40::r :: "{v : (Data.Heap.Skew.Skew a) | v == r}"
139:1-139:8::Data.Heap.Skew.minimum :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {VV : a | VV == minimum x1}"
139:24-139:25::x :: "{VV : a | VV == x}"
169:1-169:5::Data.Heap.Skew.elts :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : (Data.Set.Internal.Set a) | VV == elts x2}"
169:13-169:20::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
170:22-170:74::$dOrd_a2RN :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a2RN}"
170:30-170:65::lq_anf$##7205759403792804943 :: "(Data.Set.Internal.Set a)"
170:39-170:55::lq_anf$##7205759403792804941 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng rt}"
170:52-170:54::rt :: "{VV : a | VV == rt}"
170:56-170:64::lq_anf$##7205759403792804942 :: "{v : (Data.Set.Internal.Set a) | v == elts l}"
170:62-170:63::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
170:66-170:74::lq_anf$##7205759403792804944 :: "{v : (Data.Set.Internal.Set a) | v == elts r}"
170:72-170:73::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
177:1-177:7::Data.Heap.Skew.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
177:10-177:11::x :: "a"
181:1-181:18::Data.Heap.Skew.skewBoundedByRoot :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {r : (Data.Heap.Skew.Skew {VV : a | minimum x1 <= VV}) | size x1 == size r}"
181:35-181:46::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
181:40-181:42::rt :: "{VV : a | VV == rt}"
181:43-181:44::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
181:45-181:46::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
185:1-185:22::Data.Heap.Skew.boundedSkewTransitive :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:{VV : a | VV <= x1} -> {r : (Data.Heap.Skew.Skew {VV : a | x3 <= VV}) | size x2 == size r}"
185:25-185:26::s :: "(Data.Heap.Skew.Skew a)"
189:1-189:6::Data.Heap.Skew.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n(Data.Heap.Skew.Skew a) -> (Data.Heap.Skew.Skew a) -> (Data.Heap.Skew.Skew a)"
189:7-189:9::t1 :: "(Data.Heap.Skew.Skew a)"
189:17-189:19::t1 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t1}"
190:17-190:19::ds_d2Vn :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
192:8-192:11::rt1 :: "{VV : a | VV == rt1}"
192:15-192:18::rt2 :: "{VV : a | VV == rt2}"
193:9-193:100::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
193:14-193:17::rt1 :: "{VV : a | VV == rt1}"
193:18-193:20::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
193:21-193:100::lq_anf$##7205759403792804960 :: "(Data.Heap.Skew.Skew a)"
193:28-193:30::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
193:31-193:99::lq_anf$##7205759403792804959 :: "(Data.Heap.Skew.Skew {VV : a | rt1 <= VV})"
193:54-193:57::rt2 :: "{VV : a | VV == rt2}"
193:58-193:94::lq_anf$##7205759403792804958 :: "(Data.Heap.Skew.Skew a)"
193:77-193:93::lq_anf$##7205759403792804957 :: "{v : (Data.Heap.Skew.Skew a) | right v == r2\n                               && left v == l2\n                               && root v == rt2\n                               && elts v == Set_cup (Set_cup (Set_sng rt2) (elts l2)) (elts r2)\n                               && minimum v == rt2\n                               && size v == (1 + size l2) + size r2}"
193:83-193:86::rt2 :: "{VV : a | VV == rt2}"
193:87-193:89::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
193:90-193:92::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
193:95-193:98::rt1 :: "{VV : a | VV == rt1}"
194:10-194:101::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
194:15-194:18::rt2 :: "{VV : a | VV == rt2}"
194:19-194:21::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
194:22-194:101::lq_anf$##7205759403792804956 :: "(Data.Heap.Skew.Skew a)"
194:29-194:31::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
194:32-194:100::lq_anf$##7205759403792804955 :: "(Data.Heap.Skew.Skew {VV : a | rt2 <= VV})"
194:55-194:58::rt1 :: "{VV : a | VV == rt1}"
194:59-194:95::lq_anf$##7205759403792804954 :: "(Data.Heap.Skew.Skew a)"
194:78-194:94::lq_anf$##7205759403792804953 :: "{v : (Data.Heap.Skew.Skew a) | right v == r1\n                               && left v == l1\n                               && root v == rt1\n                               && elts v == Set_cup (Set_cup (Set_sng rt1) (elts l1)) (elts r1)\n                               && minimum v == rt1\n                               && size v == (1 + size l1) + size r1}"
194:84-194:87::rt1 :: "{VV : a | VV == rt1}"
194:88-194:90::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
194:91-194:93::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
194:96-194:99::rt2 :: "{VV : a | VV == rt2}"