1:1-1:1::Data.Heap.Skew.$trModule :: "GHC.Types.Module"
51:1-51:6::Data.Heap.Skew.empty :: "forall a .\n{r : (Data.Heap.Skew.Skew a) | size r == 0\n                               && elts r == Set_empty 0}"
71:1-71:10::Data.Heap.Skew.singleton :: "forall a .\nx1:a -> {r : (Data.Heap.Skew.Skew a) | size r == 1\n                                       && elts r == Set_sng x1}"
71:11-71:12::x :: "a"
71:20-71:21::x :: "{VV : a | VV == x}"
71:22-71:26::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
71:27-71:31::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
85:1-85:7::Data.Heap.Skew.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:a -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == 1 + size x3\n                                                                     && elts r == Set_cup (elts x3) (Set_sng x2)}"
85:8-85:9::x :: "a"
85:10-85:11::t :: "(Data.Heap.Skew.Skew a)"
85:20-85:33::lq_anf$##7205759403792806365 :: "{v : (Data.Heap.Skew.Skew a) | size v == 1\n                               && elts v == Set_sng x}"
85:31-85:32::x :: "{VV : a | VV == x}"
85:34-85:35::t :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t}"
100:1-100:9::Data.Heap.Skew.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {r : (Data.Heap.Skew.Skew a) | size r == len x2\n                                         && elts r == listElts x2}"
100:15-100:19::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
101:21-101:43::$dOrd_a3cr :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a3cr}"
101:28-101:29::x :: "{VV : a | VV == x}"
101:30-101:43::lq_anf$##7205759403792806367 :: "{v : (Data.Heap.Skew.Skew a) | size v == len xs\n                               && elts v == listElts xs}"
101:40-101:42::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
144:1-144:5::Data.Heap.Skew.size :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {VV : GHC.Types.Int | VV == size x1\n                                                    && VV >= 0}"
144:13-144:14::lq_anf$##7205759403792806322 :: "{v : GHC.Prim.Int# | v == 0}"
145:21-145:22::lq_anf$##7205759403792806324 :: "GHC.Types.Int"
145:25-145:31::lq_anf$##7205759403792806325 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
145:30-145:31::l :: "{v : (Data.Heap.Skew.Skew a) | v == l}"
145:34-145:40::lq_anf$##7205759403792806327 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
145:39-145:40::r :: "{v : (Data.Heap.Skew.Skew a) | v == r}"
150:1-150:8::Data.Heap.Skew.minimum :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {VV : a | VV == minimum x1}"
150:24-150:25::x :: "{VV : a | VV == x}"
164:1-164:10::Data.Heap.Skew.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (Data.Heap.Skew.Skew a) | size r + 1 == size x2}"
164:11-164:12::t :: "{s : (Data.Heap.Skew.Skew a) | 0 < size s}"
164:28-164:46::Data.Tuple.snd :: "forall a b . x1:(a, b) -> {VV : b | VV == snd x1}"
164:32-164:46::lq_anf$##7205759403792806364 :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
164:44-164:45::lq_anf$##7205759403792806362 :: "{v : (Data.Heap.Skew.Skew a) | 0 < size v\n                               && size v >= 0\n                               && v == t}"
169:1-169:11::Data.Heap.Skew.deleteMin2 :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (a, (Data.Heap.Skew.Skew {VV : a | fst r <= VV})) | size (snd r) + 1 == size x2\n                                                                                                          && Set_cup (elts (snd r)) (Set_sng (fst r)) == elts x2}"
169:30-169:44::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Bool> .\nx1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                     && x_Tuple21 v == x1\n                                                                                     && snd v == x2\n                                                                                     && fst v == x1}"
169:31-169:32::x :: "{VV : a | VV == x}"
169:34-169:43::lq_anf$##7205759403792806359 :: "{v : (Data.Heap.Skew.Skew a) | size v == size l + size r\n                               && elts v == Set_cup (elts l) (elts r)}"
169:40-169:41::l :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == l}"
169:42-169:43::r :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == r}"
181:1-181:5::Data.Heap.Skew.elts :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : (Data.Set.Internal.Set a) | VV == elts x2}"
181:13-181:20::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
182:22-182:74::$dOrd_a391 :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a391}"
182:30-182:65::lq_anf$##7205759403792806333 :: "(Data.Set.Internal.Set a)"
182:39-182:55::lq_anf$##7205759403792806331 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng rt}"
182:52-182:54::rt :: "{VV : a | VV == rt}"
182:56-182:64::lq_anf$##7205759403792806332 :: "{v : (Data.Set.Internal.Set a) | v == elts l}"
182:62-182:63::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
182:66-182:74::lq_anf$##7205759403792806334 :: "{v : (Data.Set.Internal.Set a) | v == elts r}"
182:72-182:73::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
187:1-187:9::Data.Heap.Skew.eltsList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {VV : (Data.Set.Internal.Set a) | VV == eltsList x2}"
187:15-187:22::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
188:21-188:58::$dOrd_a38O :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a38O}"
188:29-188:44::lq_anf$##7205759403792806336 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng x}"
188:42-188:43::x :: "{VV : a | VV == x}"
188:45-188:58::lq_anf$##7205759403792806337 :: "{v : (Data.Set.Internal.Set a) | v == eltsList xs}"
188:55-188:57::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
196:1-196:7::Data.Heap.Skew.assert :: "forall a . {v : GHC.Types.Bool | v} -> a -> a"
196:10-196:11::x :: "a"
200:1-200:18::Data.Heap.Skew.skewBoundedByRoot :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {r : (Data.Heap.Skew.Skew {VV : a | minimum x1 <= VV}) | size x1 == size r\n                                                                                                            && elts x1 == elts r}"
200:35-200:46::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
200:40-200:42::rt :: "{VV : a | VV == rt}"
200:43-200:44::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
200:45-200:46::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
204:1-204:22::Data.Heap.Skew.boundedSkewTransitive :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:{VV : a | VV <= x1} -> {r : (Data.Heap.Skew.Skew {VV : a | x3 <= VV}) | size x2 == size r\n                                                                                                                                   && elts x2 == elts r}"
204:25-204:26::s :: "(Data.Heap.Skew.Skew a)"
208:1-208:6::Data.Heap.Skew.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == size x2 + size x3\n                                                                                           && elts r == Set_cup (elts x2) (elts x3)}"
208:7-208:9::t1 :: "(Data.Heap.Skew.Skew a)"
208:17-208:19::t1 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t1}"
209:17-209:19::ds_d3gF :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
211:8-211:11::rt1 :: "{VV : a | VV == rt1}"
211:15-211:18::rt2 :: "{VV : a | VV == rt2}"
212:9-212:100::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
212:14-212:17::rt1 :: "{VV : a | VV == rt1}"
212:18-212:20::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
212:21-212:100::lq_anf$##7205759403792806353 :: "(Data.Heap.Skew.Skew a)"
212:28-212:30::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
212:31-212:99::lq_anf$##7205759403792806352 :: "(Data.Heap.Skew.Skew {VV : a | rt1 <= VV})"
212:54-212:57::rt2 :: "{VV : a | VV == rt2}"
212:58-212:94::lq_anf$##7205759403792806351 :: "(Data.Heap.Skew.Skew a)"
212:77-212:93::lq_anf$##7205759403792806350 :: "{v : (Data.Heap.Skew.Skew a) | right v == r2\n                               && left v == l2\n                               && root v == rt2\n                               && elts v == Set_cup (Set_cup (Set_sng rt2) (elts l2)) (elts r2)\n                               && minimum v == rt2\n                               && size v == (1 + size l2) + size r2}"
212:83-212:86::rt2 :: "{VV : a | VV == rt2}"
212:87-212:89::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
212:90-212:92::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
212:95-212:98::rt1 :: "{VV : a | VV == rt1}"
213:10-213:101::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_cup (Set_sng x1) (elts x2)) (elts x3)\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
213:15-213:18::rt2 :: "{VV : a | VV == rt2}"
213:19-213:21::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
213:22-213:101::lq_anf$##7205759403792806349 :: "(Data.Heap.Skew.Skew a)"
213:29-213:31::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
213:32-213:100::lq_anf$##7205759403792806348 :: "(Data.Heap.Skew.Skew {VV : a | rt2 <= VV})"
213:55-213:58::rt1 :: "{VV : a | VV == rt1}"
213:59-213:95::lq_anf$##7205759403792806347 :: "(Data.Heap.Skew.Skew a)"
213:78-213:94::lq_anf$##7205759403792806346 :: "{v : (Data.Heap.Skew.Skew a) | right v == r1\n                               && left v == l1\n                               && root v == rt1\n                               && elts v == Set_cup (Set_cup (Set_sng rt1) (elts l1)) (elts r1)\n                               && minimum v == rt1\n                               && size v == (1 + size l1) + size r1}"
213:84-213:87::rt1 :: "{VV : a | VV == rt1}"
213:88-213:90::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
213:91-213:93::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
213:96-213:99::rt2 :: "{VV : a | VV == rt2}"
229:1-229:9::Data.Heap.Skew.heapSort :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size x2}"
229:17-229:19::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | eltsList v == Set_empty 0\n                                            && Set_emp (listElts v)\n                                            && len v == 0}"
231:10-231:16::minElt :: "a"
231:18-231:20::h' :: "(Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                               && VV >= minElt})"
231:24-231:36::_ :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
231:35-231:36::ds_d3hq :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
232:9-232:15::minElt :: "{VV : a | VV == minElt}"
232:18-232:29::lq_anf$##7205759403792806361 :: "{VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size h'}"
232:27-232:29::h' :: "{v : (Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                                    && VV >= minElt}) | size v >= 0\n                                                        && v == h'}"