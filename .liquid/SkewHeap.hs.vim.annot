1:1-1:1::Data.Heap.Skew.$trModule :: "GHC.Types.Module"
49:1-49:5::Data.Heap.Skew.elts :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : (Data.Set.Internal.Set a) | VV == elts x2}"
49:13-49:20::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
50:22-50:74::$dOrd_a3h4 :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a3h4}"
50:30-50:46::lq_anf$##7205759403792806797 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng rt}"
50:43-50:45::rt :: "{VV : a | VV == rt}"
50:47-50:74::lq_anf$##7205759403792806800 :: "(Data.Set.Internal.Set a)"
50:56-50:64::lq_anf$##7205759403792806798 :: "{v : (Data.Set.Internal.Set a) | v == elts l}"
50:62-50:63::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
50:65-50:73::lq_anf$##7205759403792806799 :: "{v : (Data.Set.Internal.Set a) | v == elts r}"
50:71-50:72::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
56:1-56:9::Data.Heap.Skew.eltsList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {VV : (Data.Set.Internal.Set a) | VV == eltsList x2}"
56:15-56:22::_ :: "forall a . {v : (Data.Set.Internal.Set a) | Set_emp v}"
57:21-57:58::$dOrd_a3gR :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a3gR}"
57:29-57:44::lq_anf$##7205759403792806802 :: "{v : (Data.Set.Internal.Set a) | v == Set_sng x}"
57:42-57:43::x :: "{VV : a | VV == x}"
57:45-57:58::lq_anf$##7205759403792806803 :: "{v : (Data.Set.Internal.Set a) | v == eltsList xs}"
57:55-57:57::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
64:1-64:7::Data.Heap.Skew.assert :: "forall a . {VV : GHC.Types.Bool | VV} -> a -> a"
64:10-64:11::x :: "a"
71:1-71:5::Data.Heap.Skew.size :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {VV : GHC.Types.Int | VV == size x1\n                                                    && VV >= 0}"
71:13-71:14::lq_anf$##7205759403792806805 :: "{v : GHC.Prim.Int# | v == 0}"
72:21-72:22::lq_anf$##7205759403792806807 :: "GHC.Types.Int"
72:25-72:31::lq_anf$##7205759403792806808 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
72:30-72:31::l :: "{v : (Data.Heap.Skew.Skew a) | v == l}"
72:34-72:40::lq_anf$##7205759403792806810 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
72:39-72:40::r :: "{v : (Data.Heap.Skew.Skew a) | v == r}"
78:1-78:6::Data.Heap.Skew.empty :: "forall a .\n{r : (Data.Heap.Skew.Skew a) | size r == 0\n                               && elts r == Set_empty 0}"
84:1-84:5::Data.Heap.Skew.null :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {b : GHC.Types.Bool | b <=> size x1 == 0}"
84:21-84:25::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
85:21-85:26::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
91:1-91:10::Data.Heap.Skew.singleton :: "forall a .\nx1:a -> {r : (Data.Heap.Skew.Skew a) | size r == 1\n                                       && elts r == Set_sng x1}"
91:11-91:12::x :: "a"
91:20-91:21::x :: "{VV : a | VV == x}"
91:22-91:26::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
91:27-91:31::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
99:1-99:7::Data.Heap.Skew.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:a -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == 1 + size x3\n                                                                     && elts r == Set_cup (elts x3) (Set_sng x2)}"
99:8-99:9::x :: "a"
99:10-99:11::t :: "(Data.Heap.Skew.Skew a)"
99:20-99:33::lq_anf$##7205759403792806856 :: "{v : (Data.Heap.Skew.Skew a) | size v == 1\n                               && elts v == Set_sng x}"
99:31-99:32::x :: "{VV : a | VV == x}"
99:34-99:35::t :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t}"
106:1-106:9::Data.Heap.Skew.fromList :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {r : (Data.Heap.Skew.Skew a) | size r == len x2\n                                         && elts r == eltsList x2}"
106:15-106:19::_ :: "forall a .\n{v : (Data.Heap.Skew.Skew a) | elts v == Set_empty 0\n                               && size v == 0}"
107:21-107:43::$dOrd_a3gc :: "{v : (GHC.Classes.Ord a) | v == $dOrd_a3gc}"
107:28-107:29::x :: "{VV : a | VV == x}"
107:30-107:43::lq_anf$##7205759403792806858 :: "{v : (Data.Heap.Skew.Skew a) | size v == len xs\n                               && elts v == eltsList xs}"
107:40-107:42::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
115:1-115:4::Data.Heap.Skew.app :: "forall a .\nx1:a -> x2:[a] -> x3:[a] -> {r : [a] | eltsList r == Set_cup (Set_sng x1) (Set_cup (eltsList x2) (eltsList x3))\n                                       && len r == (1 + len x2) + len x3}"
115:5-115:6::x :: "a"
115:10-115:12::l2 :: "[a]"
115:15-115:16::x :: "{VV : a | VV == x}"
115:17-115:19::l2 :: "{v : [a] | len v >= 0\n           && v == l2}"
116:18-116:19::h :: "{VV : a | VV == h}"
116:22-116:34::lq_anf$##7205759403792806815 :: "{v : [a] | eltsList v == Set_cup (Set_sng x) (Set_cup (eltsList t) (eltsList l2))\n           && len v == (1 + len t) + len l2}"
116:27-116:28::x :: "{VV : a | VV == x}"
116:29-116:30::t :: "{v : [a] | len v >= 0\n           && v == t}"
116:31-116:33::l2 :: "{v : [a] | len v >= 0\n           && v == l2}"
124:1-124:5::Data.Heap.Skew.fst' :: "forall a b c . x1:(a, b, c) -> {VV : a | VV == fst' x1}"
124:18-124:19::x :: "{VV : a | VV == x}"
128:1-128:5::Data.Heap.Skew.snd' :: "forall a b c . x1:(a, b, c) -> {VV : b | VV == snd' x1}"
128:18-128:19::x :: "{VV : a | VV == x}"
132:1-132:5::Data.Heap.Skew.trd' :: "forall a b c . x1:(a, b, c) -> {VV : c | VV == trd' x1}"
132:18-132:19::x :: "{VV : a | VV == x}"
148:1-148:17::Data.Heap.Skew.eltsSubtreeLemma :: "forall a .\nx1:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {v : (a, (Data.Heap.Skew.Skew a), (Data.Heap.Skew.Skew a)) | elts x1 == Set_cup (Set_sng (fst' v)) (Set_cup (elts (snd' v)) (elts (trd' v)))\n                                                                                                              && size x1 == (1 + size (snd' v)) + size (trd' v)\n                                                                                                              && size (snd' v) < size x1\n                                                                                                              && size (trd' v) < size x1}"
148:33-148:42::GHC.Tuple.(,,) :: "forall a b c <p3 :: b-> a c -> Bool, p2 :: a b -> Bool> .\nx1:a -> x2:{VV : b<p2 x1> | true} -> x3:{VV : c<p3 x2 x1> | true} -> {v : (a, b, c)<\\x8 VV -> {VV : b<p2 x8> | true}, \\x8 x8 VV -> {VV : c<p3 x8 x8> | true}> | x_Tuple33 v == x3\n                                                                                                                                                                && x_Tuple32 v == x2\n                                                                                                                                                                && x_Tuple31 v == x1\n                                                                                                                                                                && snd' v == x2\n                                                                                                                                                                && fst' v == x1\n                                                                                                                                                                && trd' v == x3}"
148:34-148:35::x :: "{VV : a | VV == x}"
148:37-148:38::l :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == l}"
148:40-148:41::r :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == r}"
153:1-153:4::Data.Heap.Skew.len :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | VV == len x1\n                                && VV >= 0}"
153:10-153:11::lq_anf$##7205759403792806823 :: "{v : GHC.Prim.Int# | v == 0}"
154:14-154:15::lq_anf$##7205759403792806825 :: "GHC.Types.Int"
154:18-154:24::lq_anf$##7205759403792806826 :: "{v : GHC.Types.Int | v == len xs\n                     && v >= 0}"
154:22-154:24::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
160:1-160:7::Data.Heap.Skew.toList :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {l : [a] | len l == size x1\n                                         && elts x1 == eltsList l}"
160:15-160:17::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0\n                                            && eltsList v == Set_empty 0\n                                            && Set_emp (listElts v)}"
162:10-162:12::x' :: "a"
162:14-162:16::l' :: "(Data.Heap.Skew.Skew a)"
162:18-162:20::r' :: "(Data.Heap.Skew.Skew a)"
162:24-162:42::_ :: "(a, (Data.Heap.Skew.Skew a), (Data.Heap.Skew.Skew a))"
162:41-162:42::ds_d3p4 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
163:9-163:11::l1 :: "{l : [a] | len l == size l'\n           && elts l' == eltsList l}"
163:14-163:23::Data.Heap.Skew.toList :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {l : [a] | len l == size x1\n                                         && elts x1 == eltsList l}"
163:21-163:23::l' :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == l'}"
164:9-164:11::l2 :: "{l : [a] | len l == size r'\n           && elts r' == eltsList l}"
164:14-164:23::Data.Heap.Skew.toList :: "forall a .\nx1:(Data.Heap.Skew.Skew a) -> {l : [a] | len l == size x1\n                                         && elts x1 == eltsList l}"
164:21-164:23::r' :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == r'}"
168:9-168:11::x' :: "{VV : a | VV == x'}"
168:12-168:14::l1 :: "{v : [a] | len v == size l'\n           && elts l' == eltsList v\n           && len v >= 0\n           && v == l1}"
168:15-168:17::l2 :: "{v : [a] | len v == size r'\n           && elts r' == eltsList v\n           && len v >= 0\n           && v == l2}"
177:1-177:8::Data.Heap.Skew.minimum :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {VV : a | VV == minimum x1}"
177:24-177:25::x :: "{VV : a | VV == x}"
185:1-185:10::Data.Heap.Skew.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (Data.Heap.Skew.Skew a) | size r + 1 == size x2}"
185:11-185:12::t :: "{s : (Data.Heap.Skew.Skew a) | 0 < size s}"
185:28-185:46::Data.Tuple.snd :: "forall a b . x1:(a, b) -> {VV : b | VV == snd x1}"
185:32-185:46::lq_anf$##7205759403792806855 :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
185:44-185:45::lq_anf$##7205759403792806853 :: "{v : (Data.Heap.Skew.Skew a) | 0 < size v\n                               && size v >= 0\n                               && v == t}"
190:1-190:11::Data.Heap.Skew.deleteMin2 :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:{s : (Data.Heap.Skew.Skew a) | 0 < size s} -> {r : (a, (Data.Heap.Skew.Skew {VV : a | fst r <= VV})) | size (snd r) + 1 == size x2\n                                                                                                          && Set_cup (elts (snd r)) (Set_sng (fst r)) == elts x2}"
190:30-190:44::GHC.Tuple.(,) :: "forall a b <p2 :: a b -> Bool> .\nx1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                     && x_Tuple21 v == x1\n                                                                                     && snd v == x2\n                                                                                     && fst v == x1}"
190:31-190:32::x :: "{VV : a | VV == x}"
190:34-190:43::lq_anf$##7205759403792806850 :: "{v : (Data.Heap.Skew.Skew a) | size v == size l + size r\n                               && elts v == Set_cup (elts l) (elts r)}"
190:40-190:41::l :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == l}"
190:42-190:43::r :: "{v : (Data.Heap.Skew.Skew {VV : a | x <= VV}) | size v >= 0\n                                                && v == r}"
198:1-198:18::Data.Heap.Skew.skewBoundedByRoot :: "forall a .\nx1:{VV : (Data.Heap.Skew.Skew a) | 0 < size VV} -> {r : (Data.Heap.Skew.Skew {VV : a | minimum x1 <= VV}) | size x1 == size r\n                                                                                                            && elts x1 == elts r}"
198:35-198:46::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
198:40-198:42::rt :: "{VV : a | VV == rt}"
198:43-198:44::l :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == l}"
198:45-198:46::r :: "{v : (Data.Heap.Skew.Skew {VV : a | rt <= VV}) | size v >= 0\n                                                 && v == r}"
203:1-203:22::Data.Heap.Skew.boundedSkewTransitive :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:{VV : a | VV <= x1} -> {r : (Data.Heap.Skew.Skew {VV : a | x3 <= VV}) | size x2 == size r\n                                                                                                                                   && elts x2 == elts r}"
203:25-203:26::s :: "(Data.Heap.Skew.Skew a)"
207:1-207:6::Data.Heap.Skew.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> x3:(Data.Heap.Skew.Skew a) -> {r : (Data.Heap.Skew.Skew a) | size r == size x2 + size x3\n                                                                                           && elts r == Set_cup (elts x2) (elts x3)}"
207:7-207:9::t1 :: "(Data.Heap.Skew.Skew a)"
207:17-207:19::t1 :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0\n                               && v == t1}"
208:17-208:19::ds_d3mP :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
210:8-210:11::rt1 :: "{VV : a | VV == rt1}"
210:15-210:18::rt2 :: "{VV : a | VV == rt2}"
211:9-211:100::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
211:14-211:17::rt1 :: "{VV : a | VV == rt1}"
211:18-211:20::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
211:21-211:100::lq_anf$##7205759403792806844 :: "(Data.Heap.Skew.Skew a)"
211:28-211:30::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
211:31-211:99::lq_anf$##7205759403792806843 :: "(Data.Heap.Skew.Skew {VV : a | rt1 <= VV})"
211:54-211:57::rt2 :: "{VV : a | VV == rt2}"
211:58-211:94::lq_anf$##7205759403792806842 :: "(Data.Heap.Skew.Skew a)"
211:77-211:93::lq_anf$##7205759403792806841 :: "{v : (Data.Heap.Skew.Skew a) | right v == r2\n                               && left v == l2\n                               && root v == rt2\n                               && elts v == Set_cup (Set_sng rt2) (Set_cup (elts l2) (elts r2))\n                               && minimum v == rt2\n                               && size v == (1 + size l2) + size r2}"
211:83-211:86::rt2 :: "{VV : a | VV == rt2}"
211:87-211:89::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
211:90-211:92::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
211:95-211:98::rt1 :: "{VV : a | VV == rt1}"
212:10-212:101::Data.Heap.Skew.Node :: "forall a .\nx1:a -> x2:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> x3:(Data.Heap.Skew.Skew {VV : a | x1 <= VV}) -> {v : (Data.Heap.Skew.Skew a) | right v == x3\n                                                                                                                                       && left v == x2\n                                                                                                                                       && root v == x1\n                                                                                                                                       && elts v == Set_cup (Set_sng x1) (Set_cup (elts x2) (elts x3))\n                                                                                                                                       && minimum v == x1\n                                                                                                                                       && size v == (1 + size x2) + size x3}"
212:15-212:18::rt2 :: "{VV : a | VV == rt2}"
212:19-212:21::r2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == r2}"
212:22-212:101::lq_anf$##7205759403792806840 :: "(Data.Heap.Skew.Skew a)"
212:29-212:31::l2 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt2 <= VV}) | size v >= 0\n                                                  && v == l2}"
212:32-212:100::lq_anf$##7205759403792806839 :: "(Data.Heap.Skew.Skew {VV : a | rt2 <= VV})"
212:55-212:58::rt1 :: "{VV : a | VV == rt1}"
212:59-212:95::lq_anf$##7205759403792806838 :: "(Data.Heap.Skew.Skew a)"
212:78-212:94::lq_anf$##7205759403792806837 :: "{v : (Data.Heap.Skew.Skew a) | right v == r1\n                               && left v == l1\n                               && root v == rt1\n                               && elts v == Set_cup (Set_sng rt1) (Set_cup (elts l1) (elts r1))\n                               && minimum v == rt1\n                               && size v == (1 + size l1) + size r1}"
212:84-212:87::rt1 :: "{VV : a | VV == rt1}"
212:88-212:90::l1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == l1}"
212:91-212:93::r1 :: "{v : (Data.Heap.Skew.Skew {VV : a | rt1 <= VV}) | size v >= 0\n                                                  && v == r1}"
212:96-212:99::rt2 :: "{VV : a | VV == rt2}"
228:1-228:9::Data.Heap.Skew.heapSort :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(Data.Heap.Skew.Skew a) -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size x2\n                                                                         && eltsList VV == elts x2}"
228:17-228:19::_ :: "forall a <p :: a a -> Bool> .\n{v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0\n                                            && eltsList v == Set_empty 0\n                                            && Set_emp (listElts v)}"
230:10-230:16::minElt :: "a"
230:18-230:20::h' :: "(Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                               && VV >= minElt})"
230:24-230:36::_ :: "(a, (Data.Heap.Skew.Skew {VV : a | fst x4 <= VV}))"
230:35-230:36::ds_d3ni :: "{v : (Data.Heap.Skew.Skew a) | size v >= 0}"
231:9-231:15::minElt :: "{VV : a | VV == minElt}"
231:18-231:29::lq_anf$##7205759403792806852 :: "{VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == size h'\n                                           && eltsList VV == elts h'}"
231:27-231:29::h' :: "{v : (Data.Heap.Skew.Skew {VV : a | minElt <= VV\n                                    && VV >= minElt}) | size v >= 0\n                                                        && v == h'}"
235:1-235:14::Data.Heap.Skew.sortUsingHeap :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[a] -> {VV : [a]<\\x1 VV -> {VV : a | x1 <= VV}> | len VV == len x2\n                                                     && eltsList VV == eltsList x2}"
235:17-235:25::lq_anf$##7205759403792806859 :: "x1:(Data.Heap.Skew.Skew a) -> {v : [a]<\\x5 VV -> {VV : a | x5 <= VV}> | len v == size x1\n                                                                        && eltsList v == elts x1}"
235:28-235:36::lq_anf$##7205759403792806860 :: "x1:[a] -> {v : (Data.Heap.Skew.Skew a) | size v == len x1\n                                         && elts v == eltsList x1}"